---
title: 数组
date: 2021-02-10 18:23:37
updated: 2021-07-27 19:11:40
tags: 算法
---

**数组：存放在连续内存空间上的相同类型数据的集合，二维数组不连续。**

## 二分查找

题目要点：有序、无重复元素。

思路：不断缩小查找范围

① 当在循环体内可以找到**确定的目标解**时，且目标解一定在`[0,len(nums)-1]` 的区间内，此时的右边界初始化为`len(nums)-1`，循环条件为`left<=right`，这样可以判断到**每一个元素**。

 ② 当需要搜索边界问题或插入位置等问题时，根据目标解的可能位置，决定右边界的初始值。循环时的条件为`left<right` ，循环体内通过**排除**元素不可能存在的区间，始终将区间视为左闭右闭区间`[left, right]`，来缩小查询范围。退出循环时`left==right`，且区间内只有一个元素。视情况决定是否需要判断该元素满不满足条件。

<!--more-->

**注意**：mid的确定方式应该为`mid = left+ (right-left)/2`，为了防止`left+right`溢出(python中溢出后可以自动转换为长整型)，因此不采用`(left+right)//2`的方式；当缩小边界时带有`left=mid`语句时，此时当区间内只剩下两个元素时，区间为`[mid, right]`，会陷入死循环，因此mid的确定方式应调整为向上取整，即`mid = left+ (right-left)/2`。

参考：https://leetcode-cn.com/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/ 

### 34.  在排序数组中查找元素的第一个和最后一个位置

思路：搜索第一个位置时，排除大于或小于目标元素的区间，当找到等于目标元素的元素时，**缩小**右边界的位置，保证目标元素在区间内；最后一个位置同理。

### 33. 搜索旋转排序数组

思路：**保证永远在有序区间内查找。**先判断首元素与中间元素的大小，如果`nums[left]<=nums[mid]`（因为计算向下取整，保证**只剩两个甚至一个**元素时也符合逻辑），则说明前半部分有序；否则后半部分有序。同时判断目标元素是否在有序区间内，若在，则缩小区间，否则排除该区间。

**注**：while循环条件内应该为`left<=right`，因为本题应该搜索到每一个元素

### 81. 搜索旋转排序数组 II

思路：同上一题，比较时只需要去掉重复项。

### 875. 爱吃香蕉的珂珂

思路：每小时最少吃一根，最多吃N堆中最多的根数，以`[1,max]`为区间，二分查找最小值可以恰好在H小时内完成。

### 153. 寻找排序数组中的最小值

思路：首先观察数组中的元素，选择出**排除区间**。如果将左边界元素与中间元素比较，当左边界元素小于中间元素时，最小值可能在中间元素的右边，eg.`[3,4,5,1,2]`，也可能在中间元素的左边eg.`[1,2,3]`.所以如果选择左边界进行比较，不能确定排除区间。因此选择右边界进行比较，以确定排除区间，如果中间元素小于右边界，说明最小值元素在中间元素以左（包括中间元素），否则在中间元素以右（不包括中间元素）。

### 154. 寻找排序数组中的最小值Ⅱ

思路：同上一题，比较时只需要去掉重复项。

### 1300. 转变数组后最接近目标值的数组和

思路：其实是在数组中的最小元素和最大元素之间找，二分查找可以优化时间复杂度。在减少搜索区间的同时，计算此时的数组和，使当前值是**第一个**使数组和大于等于目标值的数字，此时要找的值就在`当前值`和`当前值-1`之间二选一。二分查找后再对二者进行比较即可。

### 1482. 制作 m 束花所需的最少天数

思路：因为需要的天数一定是在数组的最小和最大的天数区间之内，所以采用二分查找方法不断缩小区间，以确定最小天数。根据不断变化的天数，计算当前天数可以制作得到的花的个数，以该值作为缩小区间的依据。

**注**：这道题和上一题都是根据数字的单调性，在查找最佳方案时，通过二分查找不断缩小区间，找到刚好满足题目要求的**临界值**。

### 1818. 绝对值差和

思路：首先对数组nums1排序，然后遍历两个数组并求和，记录每对元素当前的绝对值差值，然后找到nums2与排序后的数组中大小最接近元素的下标i，**最接近**也可能是该下标左边的元素（如果不断收缩左边界），因此需要比较下标为i与i-1元素哪个与nums2的当前元素最接近。最后不断更新替换后绝对值变化的**最大值**。

**注**：求和结果可能很大，因此求和的变量应该用**long**定义，避免溢出。






## 位运算

### 1734. 解码异或后的排列

思路：此题中有一个重要的条件：**数组是前n个正整数的排列**。因此数组`perm`的全部异或，即前n个正整数的异或。数组`perm`中除去第一个元素`perm[0]`的异或，可以通过加密后的数组`encoded`求得：因为`encoded[i]=perm[i] ^ perm[i+1]`，所以在数组`encoded`中奇数位置的元素异或就是`perm`中后面元素的异或。eg. `encoded: [6,5,4,6], perm: [2,4,1,5,3]`，其中5是4和1的异或，6是5和3的异或。通过这两组异或就可以得到`perm[0]`。

### 1310. 子数组异或查询

思路：该题利用`x ^ x = 0, 0 ^ y = y` ,（`x ^ y = z`，则有`x ^ z = y`）的条件求解。假设有一个区间`[a,b]`，则该区间的异或为：`[0, a-1] ^ [0, a-1] ^ [a, b]`.等价于`[0, a-1] ^ [0, b]`.所以本题只需要首先保存从0开始的任意位置的所有异或结果。

**trick**: 初始化一个长度为`arr.length + 1`的数组`record`，其中`record[0]=0`，从索引1开始，`record[i] = record[i-1] ^ arr[i-1] `，这样保存的数组`record[i]`即`arr`中前`i-1`个所有元素的异或。

### 2的幂

思路：一个数n是2的幂，当且仅当n是正整数，并且n的二进制表示中仅包含1个1。

因此我们可以考虑使用位运算，将n的二进制表示中最低位的那个1提取出来，再判断剩余的数值是否为0即可。下面介绍两种常见的与「二进制表示中最低位」相关的位运算技巧。

- 第一个技巧是`n & (n - 1)`

其中`&`表示按位与运算。该位运算技巧可以直接将n二进制表示的最低位1移除，它的原理如下：

假设n的二进制表示为 $(a10⋯0)_2$，其中a表示若干个高位，1表示最低位的那个1，0⋯0表示后面的若干个0，那么n−1的二进制表示为：$(a01⋯1)_2$
​

将$(a10⋯0)_2$与$(a01⋯1)_2$进行按位与运算，高位a不变，在这之后的所有位都会变为 0，这样我们就将最低位的那个1移除了。

因此，如果n是正整数并且 `n & (n - 1) = 0`，那么n就是2的幂。

- 第二个技巧是`n & (-n)`

其中−n是n的相反数，是一个负数。该位运算技巧可以直接获取n二进制表示的最低位的1。

由于负数是按照补码规则在计算机中存储的，−n的二进制表示为n的二进制表示的每一位取反再加上1，因此它的原理如下：

假设n的二进制表示为$(a10⋯0)_2$，其中a表示若干个高位，1表示最低位的那个1,0⋯0表示后面的若干个0，那么−n的二进制表示为：$(a¯01⋯1)_2+(1)_2=(a¯10⋯0)_2$,其中 a¯
表示将a每一位取反。将$(a10⋯0)_2$与$(a¯10⋯0)_2$进行按位与运算，高位全部变为 0，最低位的1以及之后的所有0不变，这样我们就获取了n二进制表示的最低位的1。

因此，如果n是正整数并且`n & (-n) = n`，那么n就是2的幂。





## 数学

### 523. 连续的子数组和
思路：计算出数组nums的前缀和数组prefixSums[i]。

当 prefixSums[q]−prefixSums[p]为 k的倍数时，prefixSums[p]和 prefixSums[q]除以 k 的**余数相同**。因此只需要计算每个下标对应的前缀和除以k的余数即可，使用哈希表存储每个余数第一次出现的下标。

规定空的前缀的结束下标为 −1，由于空的前缀的元素和为 0，因此在哈希表中存入键值对 (0,−1)。计算每个下标对应的前缀和除以 k的余数，并维护哈希表。


## 双指针

### 415. 字符串相加

思路：利用双指针**模拟**两个整数的加法过程，两个指针分别从两个字符串的最右侧开始**同时**向左移动，记录当前两个字符相加的结果（以及进位），将该结果拼接在结果字符串后，同时需要判断是否**进位**，带入到下一次循环。

### 165. 比较版本号

思路：按照'.'分割两个版本号，**跳过'.'**分别比较两个'.'之间的数字，将各区间内的数字看作一个十进制的数字，将每一位乘以10之后累加，如果某个区间内的两个十进制数字有大小关系，则直接返回，否则继续遍历，如果一直没有大小关系，表明两个版本号相等。

### 15. 三数之和

思路：先将数组排序，遍历数组时每轮以下标为i的元素为基准，采用双指针，第一个指针指向i+1的元素，第二个指针指向nums.length-1的元素，从两端向中间收缩，同时计算二者之和的**相反数**与基准的大小关系，根据大小关系收缩左右边界。

**注**：
 1. 在**遍历数组**以及**移动指针**时，如果当前元素与上一个元素相等，则跳过当前元素（**去重**）
 2. 在得到一组三数之和为0时，应该继续同时移动两个指针，因为可能有多组数与当前基准的和为0

### 找出数组中重复的数字

思路：因为数组中的数字是从0~n-1，所以可以通过把当前元素交换至对应位置，判断数组中重复的数字。在遍历数组时，如果当前元素不在对应的位置，比如说数字3在下标2的位置，则将数字3与下标为3的元素交换位置，如果要交换的位置上的数字与当前数字相同，则是重复数字。

### 二维数组中的查找

思路：二维数组的横向和纵向都是依次递增排列的，因此遍历查找时应该确定一个维度，比如选择右上角（左下角）元素为起始比较元素，如果目标元素比当前元素大（小），则比较的方向应该向下偏移。也就是说，每次变换遍历方向可以唯一确定。

### 替换字符串中的空格

思路：如果从直观感受从头到尾遍历，检查是否遇到空格，并替换，时间复杂度会达到$O(n^2)$。因为需要多次移动元素，所以可以采用从后向前遍历的方式，首先记录字符串中空格的数量，将原字符串加长至替换后的长度，设置指针p指向原长度的末尾，指针q指向新长度的末尾，将原字符移动到新位置，如果遇到空格则移动指针q并依次添加字符'0','2','%'。