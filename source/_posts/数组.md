---
title: 数组
date: 2021-02-10 18:23:37
updated: 2021-05-30 16:23:47
tags: 算法
---

**数组：存放在连续内存空间上的相同类型数据的集合，二维数组不连续。**

## 二分查找

题目要点：有序、无重复元素。

思路：不断缩小查找范围

① 当在循环体内可以找到**确定的目标解**时，且目标解一定在`[0,len(nums)-1]` 的区间内，此时的右边界初始化为`len(nums)-1`，循环条件为`left<=right`，这样可以判断到**每一个元素**。

 ② 当需要搜索边界问题或插入位置等问题时，根据目标解的可能位置，决定右边界的初始值。循环时的条件为`left<right` ，循环体内通过**排除**元素不可能存在的区间，始终将区间视为左闭右闭区间`[left, right]`，来缩小查询范围。退出循环时`left==right`，且区间内只有一个元素。视情况决定是否需要判断该元素满不满足条件。

<!--more-->

**注意**：mid的确定方式应该为`mid = left+ (right-left)/2`，为了防止`left+right`溢出(python中溢出后可以自动转换为长整型)，因此不采用`(left+right)//2`的方式；当缩小边界时带有`left=mid`语句时，此时当区间内只剩下两个元素时，区间为`[mid, right]`，会陷入死循环，因此mid的确定方式应调整为向上取整，即`mid = left+ (right-left)/2`。

参考：https://leetcode-cn.com/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/ 

### 34.  在排序数组中查找元素的第一个和最后一个位置

思路：搜索第一个位置时，排除大于或小于目标元素的区间，当找到等于目标元素的元素时，**缩小**右边界的位置，保证目标元素在区间内；最后一个位置同理。

### 33. 搜索旋转排序数组

思路：**保证永远在有序区间内查找。**先判断首元素与中间元素的大小，如果`nums[left]<=nums[mid]`（因为计算向下取整，保证**只剩两个甚至一个**元素时也符合逻辑），则说明前半部分有序；否则后半部分有序。同时判断目标元素是否在有序区间内，若在，则缩小区间，否则排除该区间。

**注**：while循环条件内应该为`left<=right`，因为本题应该搜索到每一个元素

### 81. 搜索旋转排序数组 II

思路：同上一题，比较时只需要去掉重复项。

### 875. 爱吃香蕉的珂珂

思路：每小时最少吃一根，最多吃N堆中最多的根数，以`[1,max]`为区间，二分查找最小值可以恰好在H小时内完成。

### 153. 寻找排序数组中的最小值

思路：首先观察数组中的元素，选择出**排除区间**。如果将左边界元素与中间元素比较，当左边界元素小于中间元素时，最小值可能在中间元素的右边，eg.`[3,4,5,1,2]`，也可能在中间元素的左边eg.`[1,2,3]`.所以如果选择左边界进行比较，不能确定排除区间。因此选择右边界进行比较，以确定排除区间，如果中间元素小于右边界，说明最小值元素在中间元素以左（包括中间元素），否则在中间元素以右（不包括中间元素）。

### 154. 寻找排序数组中的最小值Ⅱ

思路：同上一题，比较时只需要去掉重复项。

### 1300. 转变数组后最接近目标值的数组和

思路：其实是在数组中的最小元素和最大元素之间找，二分查找可以优化时间复杂度。在减少搜索区间的同时，计算此时的数组和，使当前值是**第一个**使数组和大于等于目标值的数字，此时要找的值就在`当前值`和`当前值-1`之间二选一。二分查找后再对二者进行比较即可。

### 1482. 制作 m 束花所需的最少天数

思路：因为需要的天数一定是在数组的最小和最大的天数区间之内，所以采用二分查找方法不断缩小区间，以确定最小天数。根据不断变化的天数，计算当前天数可以制作得到的花的个数，以该值作为缩小区间的依据。

**注**：这道题和上一题都是根据数字的单调性，在查找最佳方案时，通过二分查找不断缩小区间，找到刚好满足题目要求的**临界值**。







## 位运算

### 1734. 解码异或后的排列

思路：此题中有一个重要的条件：**数组是前n个正整数的排列**。因此数组`perm`的全部异或，即前n个正整数的异或。数组`perm`中除去第一个元素`perm[0]`的异或，可以通过加密后的数组`encoded`求得：因为`encoded[i]=perm[i] ^ perm[i+1]`，所以在数组`encoded`中奇数位置的元素异或就是`perm`中后面元素的异或。eg. `encoded: [6,5,4,6], perm: [2,4,1,5,3]`，其中5是4和1的异或，6是5和3的异或。通过这两组异或就可以得到`perm[0]`。

### 1310. 子数组异或查询

思路：该题利用`x ^ x = 0, 0 ^ y = y` ,（`x ^ y = z`，则有`x ^ z = y`）的条件求解。假设有一个区间`[a,b]`，则该区间的异或为：`[0, a-1] ^ [0, a-1] ^ [a, b]`.等价于`[0, a-1] ^ [0, b]`.所以本题只需要首先保存从0开始的任意位置的所有异或结果。

**trick**: 初始化一个长度为`arr.length + 1`的数组`record`，其中`record[0]=0`，从索引1开始，`record[i] = record[i-1] ^ arr[i-1] `，这样保存的数组`record[i]`即`arr`中前`i-1`个所有元素的异或。

## 2的幂

思路：一个数n是2的幂，当且仅当n是正整数，并且n的二进制表示中仅包含1个1。

因此我们可以考虑使用位运算，将n的二进制表示中最低位的那个1提取出来，再判断剩余的数值是否为0即可。下面介绍两种常见的与「二进制表示中最低位」相关的位运算技巧。

- 第一个技巧是`n & (n - 1)`

其中`&`表示按位与运算。该位运算技巧可以直接将n二进制表示的最低位1移除，它的原理如下：

假设n的二进制表示为 $(a10⋯0)_2$，其中a表示若干个高位，1表示最低位的那个1，0⋯0表示后面的若干个0，那么n−1的二进制表示为：$(a01⋯1)_2$
​

将$(a10⋯0)_2$与$(a01⋯1)_2$进行按位与运算，高位a不变，在这之后的所有位都会变为 0，这样我们就将最低位的那个1移除了。

因此，如果n是正整数并且 `n & (n - 1) = 0`，那么n就是2的幂。

- 第二个技巧是`n & (-n)`

其中−n是n的相反数，是一个负数。该位运算技巧可以直接获取n二进制表示的最低位的1。

由于负数是按照补码规则在计算机中存储的，−n的二进制表示为n的二进制表示的每一位取反再加上1，因此它的原理如下：

假设n的二进制表示为$(a10⋯0)_2$，其中a表示若干个高位，1表示最低位的那个1,0⋯0表示后面的若干个0，那么−n的二进制表示为：$(a¯01⋯1)_2+(1)_2=(a¯10⋯0)_2$,其中 a¯
表示将a每一位取反。将$(a10⋯0)_2$与$(a¯10⋯0)_2$进行按位与运算，高位全部变为 0，最低位的1以及之后的所有0不变，这样我们就获取了n二进制表示的最低位的1。

因此，如果n是正整数并且`n & (-n) = n`，那么n就是2的幂。