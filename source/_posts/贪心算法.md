---
title: 贪心算法
date: 2021-04-20 18:40:17
tags: 算法
---

贪心的本质是选择每一阶段的**局部最优**，从而达到**全局最优**。

1. 创建数学模型来描述问题，明确什么是最优解。
2. 把求解的问题分成若干子问题，明确什么是子问题的最优解。
3. 对每一子问题求解，得到子问题的局部最优解。
4. 把子问题的解局部最优解合成原来解问题的一个解。

<!--more-->

## 455. 分发饼干

思路：为了尽可能满足数量多的孩子，<u>则饼干大的尺寸应该优先分发给胃口值大的孩子</u>。因此，应该首先将饼干尺寸数组和胃口值数组按照**升序**进行排序，再遍历两个数组，**从后向前**依次按照两个数组中值的大小关系累加。

**trick**：可以只是用一个for循环，提前设置饼干尺寸数组的索引index，然后遍历胃口值数组，如果饼干尺寸满足胃口值，才需要变化index，即index--。**或者**采用while循环。

## 376. 摆动序列

思路：将数组中的值按照大小描点画图，摆动的序列呈现为多峰的形状，因此只要有两个连续上升或下降的数字，就不是摆动的序列，应该跳过。所以首先设置前两个数字的差值`preDiff`和当前两个数字的差值`curDiff`均为0，遍历时，计算当前差值，如果两个差值符号相反，则依次将`preDiff = curDiff`，同时累加峰值的个数；否则不做任何处理。

**注**：初始的差值为0，因此前一个差值可以为0，判断条件应带有0。同时默认有一个峰值，也就是说只要存在两个**不同**的元素，就会有两个峰值。

## 53. 最大子序列

思路：计算“和“最大的子序列，首先从头遍历，并累加元素，如果当前累加和为负数，则立刻舍弃当前的元素，从下一个元素开始重新计算，并记录已经计算过**正数和**的**最大值**，保证得到的结果是最大值。

**注**：如果当前累加和为负数，说明当前元素一定为负数，因为之前的和一直为正数，加到了这个数突然变负数，说明当前元素是一个较大的负数，因此累加和应该从**零**，也就是**下一个元素**开始计算，而不是当前元素。

## 122. 买卖股票的最佳时机Ⅱ

思路：把总的利润分解为每天的利润，然后将各个**正**利润累加，就是可得的最大利润。也就是说，**每两天**就计算利润，将总利润分解，舍弃负利润。

## 55. 跳跃游戏Ⅰ

思路：每一次跳跃都有一个**跳跃范围**，因此遍历数组，使遍历项`i`在跳跃范围内，记录当前位置可以覆盖到的最大范围，不断**更新**最大范围，如果该范围可以覆盖数组的长度，则返回true，表示可以到达最后一个位置。

**注**：遍历时，循环的最大值应该可以**取到**范围，即`<=`.

## 45. 跳跃游戏Ⅱ

思路：首先明确题目给出的条件是**一定会达到最后一个位置**，同时如果要求跳跃的最少次数，也就是每次跳跃的步长保证最大，也就是贪心中的局部最优。所以在遍历数组时， 同样设置一个最大边界，如果遍历项`i`达到最大边界时（仍然在循环内，说明还没达到最后一个位置），更新最大边界，同时次数+1，也就是从下一个元素再起跳。

**注**：从第一个元素起跳时，一定会落下，也就是说此时的跳跃次数已经为**1**，所以遍历项`i`应该到数组的倒数第二项终止，如果继续遍历最后一个元素，则会导致跳跃次数多加一次。（可以理解为如果到达最后一个元素，则不需要再次起跳，因此不需要再进行计数）

## 1005. K次取反后最大化的数组和

思路：数组中有正数也有负数，因此应该将次数首先用在对**负数**取反上，并且优先对**绝对值大**的负数进行取反，这样可以保证取反后的数组和尽可能大，如果所有的负数都取反后，仍然有取反的次数，即K>0，那么应该将剩下的所有次数都用在取反绝对值最小的数，无论该数最后是正还是负，取反的结果都是最优的。

**注**：首先应该按照**绝对值**的大小对数组降序排序，然后按顺序遍历。

## 134. 加油站

思路：首先判断总油量与总油耗的大小，也就是总油量是否高于油耗，如果不是则直接返回-1.然后，从头开始遍历数组，计算油量与油耗的差值，并进行**累加**，同时记录索引值，如果到某一个位置的累加和为负数，则说明不能到达，此时应该更新索引值（+1），同时将累加和清零，重新开始计算。

## 135. 分发糖果

思路：因为需要利用相邻元素的大小关系判断糖果的数量，所以应该依次遍历，为了保证充分考虑一个元素的左右关系，所有应该分别进行**左右遍历**。首先初始化一个元素全部为**1**的数组，然后进行左遍历（从前向后），依次比较元素的大小，只要后一个元素比前一个大，就将前一个元素的糖果数进行+1，否则保持1不变，最后进行右遍历（从后向前），如果前一个元素比后一个元素大，**此时需要取左遍历后糖果数和右遍历糖果数+1后的最大值**，保证题目中相邻的分数高的糖果数多的条件。

**注**：

1. 一开始**错误**的思路是找到数组中最小的元素，从该元素开始分别向左和右判断大小关系，以计算糖果数量，这个想法错的地方是<u>数组中可能有多个同样小的元素</u>，无法从每个最小元素开始左右判断。
2. 右遍历时，应该从后向前而不是从前向后，如果是从前向后，不能得到从右侧得到的**累加结果**。

## 860. 柠檬水找零

思路：遍历数组时，记录收下5和10的个数，因为可以用作找零，而不需要记录20的个数。遇到5，则直接收下，遇到10需要用5找零，同时更新5和10的个数，遇到20，首先考虑用一个5和一个10找零，再考虑用三个5找零，因为5既可以给10找零，也可以给20找零，所以应该多留5，保证给更多的人找零。

## 406. 按身高重建队列

思路：针对两个维度的问题，首先应该确定一个维度，因为不能确定当前数前面要放哪些更大的数，所以不妨先放置身高最高的元素，因为它不需要考虑前面更高的身高，这样就确定了**身高**的维度。然后依次遍历，优先按照身高高的k插入到新数组中，这样后面再插入的也不会对之前的操作产生影响，保证了局部最优。

## 452. 用最少数量的箭引爆气球

思路：本题实际上是尽可能**多**找出重叠区间。首先按照**结尾**坐标对数组进行排序，并初始化**参照坐标**为第一个元素的结尾坐标，如果后面元素的起始坐标小于参照坐标，则说明两个元素是重叠的，否则需要更新参照坐标为新元素的结尾坐标，并且需要的箭数应该+1.

**注**：如果对数组按照**起始**坐标进行排序，并根据`a[1]>b[0]`判断两个区间是否重叠，会出现错误，假设第一个区间非常大，覆盖了后面很多区间，但其实这里面的区间可能会出现不重叠的情况。如`[1,8], [2,3], [5,6]`.

