---
title: 贪心算法
date: 2021-04-20 18:40:17
tags: 算法
---

贪心的本质是选择每一阶段的**局部最优**，从而达到**全局最优**。

1. 创建数学模型来描述问题。
2. 把求解的问题分成若干子问题。
3. 对每一子问题求解，得到子问题的局部最优解。
4. 把子问题的解局部最优解合成原来解问题的一个解。

<!--more-->

## 455. 分发饼干

思路：为了尽可能满足数量多的孩子，<u>则饼干大的尺寸应该优先分发给胃口值大的孩子</u>。因此，应该首先将饼干尺寸数组和胃口值数组按照**升序**进行排序，再遍历两个数组，**从后向前**依次按照两个数组中值的大小关系累加。

**trick**：可以只是用一个for循环，提前设置饼干尺寸数组的索引index，然后遍历胃口值数组，如果饼干尺寸满足胃口值，才需要变化index，即index--。**或者**采用while循环。

## 376. 摆动序列

思路：将数组中的值按照大小描点画图，摆动的序列呈现为多峰的形状，因此只要有两个连续上升或下降的数字，就不是摆动的序列，应该跳过。所以首先设置前两个数字的差值`preDiff`和当前两个数字的差值`curDiff`均为0，遍历时，计算当前差值，如果两个差值符号相反，则依次将`preDiff = curDiff`，同时累加峰值的个数；否则不做任何处理。

**注**：初始的差值为0，因此前一个差值可以为0，判断条件应带有0。同时默认有一个峰值，也就是说只要存在两个**不同**的元素，就会有两个峰值。

## 53. 最大子序列

思路：计算“和“最大的子序列，首先从头遍历，并累加元素，如果当前累加和为负数，则立刻舍弃当前的元素，从下一个元素开始重新计算，并记录已经计算过**正数和**的**最大值**，保证得到的结果是最大值。

**注**：如果当前累加和为负数，说明当前元素一定为负数，因为之前的和一直为正数，加到了这个数突然变负数，说明当前元素是一个较大的负数，因此累加和应该从**零**，也就是**下一个元素**开始计算，而不是当前元素。