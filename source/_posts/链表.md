---
title: 链表
date: 2021-04-07 18:07:06
updated: 2021-07-27 19:09:27
tags: 算法				
---

链表是一种通过指针串联在一起的线性结构，每一个节点是由数据域和指针域组成，最后一个节点的指针域指向null。

单链表中的节点只能指向节点的下一个节点；双链表中的每个节点有两个指针域，分别指向下一个节点和上一个节点，也就是说，双链表可以双向查询；循环链表首尾相连。

链表在内存中不连续分布。

## 单链表

### 203. 移除链表元素

思路：添加一个**虚拟头节点**，**便于移除原头节点**（操作统一），设置一个临时节点`temp`用于遍历链表，如果`temp.next.val==val`则移除，否则继续遍历。（注意连续要移除的目标节点）

### 707. 设计链表

思路：首先定义**虚拟头节点**，并初始化链表长度为0。可以实现以下五个功能：

- get(index)，首先判断index是否有效，若无效则返回-1。设置遍历节点cur，根据index的值，循环遍历链表，最后返回`cur.val`。
- addAtHead(val)，在虚拟头节点和真实头节点之间插入一个新值，同时长度+1。
- addAtTail(val)，利用遍历节点cur遍历到链表尾部，并将新值插入尾部，同时长度+1。
- addAtIndex(index, val)，首先判断index是否有效。若有效，则遍历到index位置**前**，并将新值插入，同时长度+1。
- deleteAtIndex(index)，首先判断index是否有效。若有效，则遍历到index位置前，删除index位置的节点，同时长度-1。

### 206. 反转链表

思路：递归或迭代。

**递归**：

​	① 确定递归函数的参数和返回值：链表的头节点

​	② 确定递归的终止条件：如果当前节点或下一个节点为空，则返回当前节点。（**为了取到最后一个节点**）

​	③ 确定单层递归的逻辑：设置新节点`cur`指向最后一个节点，递归调用前为**递**的操作，也就是终止条件，调用后为**归**的操作，**归**时将每一个节点的下一个节点的指针都指向当前节点`head.next.next = head`，此时的`head.next`仍然指向的是下一个节点，所以为了防止链表出现循环设置`head.next=null`，每一层递归都返回最后一个节点的指针**`cur`**。

**迭代**：设置当前节点（初始化为头节点）、上一个节点（初始化为空节点）以及临时节点（用于存放**原**下一个节点）。遍历链表直至当前节点为空，首先利用临时节点记录下一个节点，然后将当前节点指向上一个节点，最后完成节点`pre`和`cur`的顺次移动。

### 19. 删除链表的倒数第N个结点

思路：通过设置双指针，遍历时，快指针先遍历，直到与慢指针的距离达到n。此时让快慢指针同时移动，直到快指针的下一个节点为空，这时删除慢指针的下一个节点。

### 146. LRU缓存机制

思路：采用**哈希表**和**双向链表**实现，双向链表应该同时存放关键字和值两个元素，便于协同更新哈希表。实现时，定义成员变量：哈希表、链表的实际长度、最大长度以及虚拟头尾节点（可以使时间复杂度达到O(1)）。初始化LRU时，实际长度为0，最大长度为给定长度，定义虚拟头尾节点之间的指向关系。获取关键字时，在哈希表中判断，如果存在则返回，并且将该节点移动到头节点（表示最近使用过，删除节点，然后在头节点添加）。添加关键字时，在哈希表中判断，如果存在则直接赋值，同时移动到头节点；否则在哈希表中加入新的键值对，**直接在头节点插入新节点**，同时实际长度+1，如果此时的长度超过了最大长度，则将尾节点移除（移除时返回尾节点，便于在哈希表中删除）

### 剑指52. 两个链表的第一个公共节点

思路：利用双指针，只要没有找到公共节点，就循环遍历两个链表，如果第一个链表遍历到空节点，则跳到第二个链表的表头继续遍历，第二个链表同理，如此交叉比较，直至找到公共节点。

**注**：如果两个链表没有公共节点，最后都指向null，跳出循环。

### 从尾到头打印链表

思路：将链表中的元素从尾到头添加到结果数组中，可以借助**栈**结构后进先出的特性实现；也可以采用**递归**方式打印。