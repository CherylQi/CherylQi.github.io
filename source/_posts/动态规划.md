---
title: 动态规划
date: 2021-05-18 16:07:00
updated: 2021-05-31 20:02:53
tags: 算法
---

动态规划是为了使解决方案最优，可以通过求解子问题解决，同时每个状态都受上一个状态的选择影响。

**解题步骤**：
1. 首先明确状态转移方程，以及下标的含义
2. 确定递推公式
3. dp数组的初始化
4. 确定遍历顺序
5. 举例推导dp数组

## 746. 使用最小花费爬楼梯
思路：每次爬楼梯的花费可能来自前一节台阶或前两节台阶，所以每次花费就是对`前一节台阶`和`前两节台阶`的花费取**最小值**，作为当前台阶的花费。

## 63. 不同路径Ⅱ
思路：定义一个二维的数组dp，全部赋值为0。首先按照第一行和第一列进行初始化，如果当前位置没有障碍，则该位置之前（左或上）的所有路径都为1。然后从`dp[1][1]`开始，如果当前位置有障碍则不做改变，继续循环；如果没有障碍，则该位置的路径是上方和左方的路径之和。

## 343. 整数拆分
思路：首先计算前7个数的拆分结果，从1到7都是两个中位数的乘积。再根据这个结果，向后推算其他整数的拆分结果，`j`是遍历整数从3开始，到中位数`mid`的因数，最大值由`dp[j]*dp[i-j]`更新。

**注**：更新后面的整数时，当`j==3`时，`dp[3]`应该取3.

**官方题解**：

将 `i` 拆分成 `j `和 `i−j`的和，且 `i−j` 不再拆分成多个正整数，此时的乘积是 `j×(i−j)`；

将 `i` 拆分成 `j` 和 `i−j` 的和，且` i−j `继续拆分成多个正整数，此时的乘积是 `j×dp[i−j]`。

 `j `的取值范围是 1 到 `i−1`

 ## 1035. 不相交的线
思路：该题类似于最长上升子序列，每一步的决策由上一步决定。因此数组dp应该是对**右下**方向产生印象，如果当前的两个元素相同，则对左上角的累计值+1，否则继续取上方和左方中的最大值作为当前累计值。

## 96. 不同的二叉搜索树

思路：当节点个数n增加时，对应二叉搜索树个数为：从1开始到n遍历根节点，`总个数=左子树个数*右子树个数`不断累加。比如当n=5时，`dp[5]=dp[0]*dp[4]+dp[1]*dp[3]+dp[2]*dp[2]+dp[3]*dp[1]+dp[4]*dp[0]`，分别对应左边0子树，右边4子树；左边1子树，右边3子树，以此类推。

## 0-1背包问题

思路：首先初始化一个二维数组dp，`dp[i][j]`表示从下标为`0~i`的物品中任意取，放入容量为j的背包时，价值总和的最大值。当背包重量为0时，最大值都是0；当放入物品0时，应注意每个物品只能用**一次**，因此从后向前遍历，保证每个物品只放一次。继续遍历时，只需要考虑当前背包容量大于当前物品容量时**选与不选**（因为如果当前背包容量小，肯定不选）。如果不选，则与上一个物品的最大值相同；如果选，则当前背包重量应该减去当前物品的重量，同时加上物品的价值。在选与不选之间取一个最大值，作为当前值即可。

**滚动数组**：将二维数组压缩成一维数组，因为发生变化的元素只受**上一个**元素影响，与前面的元素都无关。

**注**：
  - 如果物品中的价值有负数，数组初始化时应为负无穷。
  - 滚动数组中也应该为倒序遍历，保证每个物品只放入一次。

## 416. 分割等和子集

思路：该题的目的是将一个数组分割成两个元素和相等的数组，因此可以转化为考虑从原数组中选出一些数字，使他们的和为总和的一半。把数组中的元素看作物品，物品的重量和价值都是元素的数值；把总和的一半看作背包的容量。把物品放入背包的过程中，如果出现当前的价值等于总和的一半，就说明可以分割。

**注**：如果按照布尔值考虑。当挑选出的数字**恰好**可以装满当前的背包时，当前状态为true。

如果不选择nums[i]，如果在 [0,i-1] 这个子区间内已经有一部分元素，使得它们的和为j，那么dp[i][j] = true；
如果选择nums[i]，如果在 [0,i-1] 这个子区间内就得找到一部分元素，使得它们的和为 j-nums[i]。


如果j恰好等于nums[i]，即单独nums[j]这个数恰好等于此时背包的容量j。

同样，如果优化为一维数组，应该从后向前遍历，保证每个元素只使用一次。

## 1049. 最后一块石头的重量Ⅱ

思路：为了让剩下的重量最小，就要尽可能地将总重量分成接近地两部分。因此，背包的容量为石头总重量的一半，每次向背包里放石头的时候，让总重量尽可能接近背包容量。所有石头最后分成两堆，其中一堆为`dp[len]`，另一堆为`sum-dp[len]`，因为len是向下取整，所以`sum-dp[len]`一定不小于`dp[len]`，因此最后剩的石头为`sum-dp[len]-dp[len]。`
