---
title: 动态规划
date: 2021-05-18 16:07:00
updated: 2021-06-24 21:06:11
tags: 算法
---

动态规划是为了使解决方案最优，可以通过求解子问题解决，同时每个状态都受上一个状态的选择影响。

**解题步骤**：
1. 首先明确状态转移方程，以及下标的含义
2. 确定递推公式
3. dp数组的初始化
4. 确定遍历顺序
5. 举例推导dp数组

## 746. 使用最小花费爬楼梯
思路：每次爬楼梯的花费可能来自前一节台阶或前两节台阶，所以每次花费就是对`前一节台阶`和`前两节台阶`的花费取**最小值**，作为当前台阶的花费。

## 63. 不同路径Ⅱ
思路：定义一个二维的数组dp，全部赋值为0。首先按照第一行和第一列进行初始化，如果当前位置没有障碍，则该位置之前（左或上）的所有路径都为1。然后从`dp[1][1]`开始，如果当前位置有障碍则不做改变，继续循环；如果没有障碍，则该位置的路径是上方和左方的路径之和。

## 343. 整数拆分
思路：首先计算前7个数的拆分结果，从1到7都是两个中位数的乘积。再根据这个结果，向后推算其他整数的拆分结果，`j`是遍历整数从3开始，到中位数`mid`的因数，最大值由`dp[j]*dp[i-j]`更新。

**注**：更新后面的整数时，当`j==3`时，`dp[3]`应该取3.

**官方题解**：

将 `i` 拆分成 `j `和 `i−j`的和，且 `i−j` 不再拆分成多个正整数，此时的乘积是 `j×(i−j)`；

将 `i` 拆分成 `j` 和 `i−j` 的和，且` i−j `继续拆分成多个正整数，此时的乘积是 `j×dp[i−j]`。

 `j `的取值范围是 1 到 `i−1`

 ## 1035. 不相交的线
思路：该题类似于最长上升子序列，每一步的决策由上一步决定。因此数组dp应该是对**右下**方向产生印象，如果当前的两个元素相同，则对左上角的累计值+1，否则继续取上方和左方中的最大值作为当前累计值。

## 96. 不同的二叉搜索树

思路：当节点个数n增加时，对应二叉搜索树个数为：从1开始到n遍历根节点，`总个数=左子树个数*右子树个数`不断累加。比如当n=5时，`dp[5]=dp[0]*dp[4]+dp[1]*dp[3]+dp[2]*dp[2]+dp[3]*dp[1]+dp[4]*dp[0]`，分别对应左边0子树，右边4子树；左边1子树，右边3子树，以此类推。

## 0-1背包问题

思路：首先初始化一个二维数组dp，`dp[i][j]`表示从下标为`0~i`的物品中任意取，放入容量为j的背包时，价值总和的最大值。当背包重量为0时，最大值都是0；当放入物品0时，应注意每个物品只能用**一次**，因此从后向前遍历，保证每个物品只放一次。继续遍历时，只需要考虑当前背包容量大于当前物品容量时**选与不选**（因为如果当前背包容量小，肯定不选）。如果不选，则与上一个物品的最大值相同；如果选，则当前背包重量应该减去当前物品的重量，同时加上物品的价值。在选与不选之间取一个最大值，作为当前值即可。

**滚动数组**：将二维数组压缩成一维数组，因为发生变化的元素只受**上一个**元素影响，与前面的元素都无关。

**注**：
  - 如果物品中的价值有负数，数组初始化时应为负无穷。
  - 滚动数组中也应该为倒序遍历，保证每个物品只放入一次。
  - 一维数组中必须先遍历物品，再遍历背包容量。因为涉及倒序遍历，如果先遍历背包容量，那么每个dp[j]中只有一个物品。

## 416. 分割等和子集

思路：该题的目的是将一个数组分割成两个元素和相等的数组，因此可以转化为考虑从原数组中选出一些数字，使他们的和为总和的一半。把数组中的元素看作物品，物品的重量和价值都是元素的数值；把总和的一半看作背包的容量。把物品放入背包的过程中，如果出现当前的价值等于总和的一半，就说明可以分割。

**注**：如果按照布尔值考虑。当挑选出的数字**恰好**可以装满当前的背包时，当前状态为true。

如果不选择nums[i]，如果在 [0,i-1] 这个子区间内已经有一部分元素，使得它们的和为j，那么dp[i][j] = true；
如果选择nums[i]，如果在 [0,i-1] 这个子区间内就得找到一部分元素，使得它们的和为 j-nums[i]。


如果j恰好等于nums[i]，即单独nums[j]这个数恰好等于此时背包的容量j。

同样，如果优化为一维数组，应该从后向前遍历，保证每个元素只使用一次。

## 1049. 最后一块石头的重量Ⅱ

思路：为了让剩下的重量最小，就要尽可能地将总重量分成接近地两部分。因此，背包的容量为石头总重量的一半，每次向背包里放石头的时候，让总重量尽可能接近背包容量。所有石头最后分成两堆，其中一堆为`dp[len]`，另一堆为`sum-dp[len]`，因为len是向下取整，所以`sum-dp[len]`一定不小于`dp[len]`，因此最后剩的石头为`sum-dp[len]-dp[len]。`

## 494. 目标和

思路：本题要求达到目标值的**最多方法数**，数字可以分为**两类**，一类为正数，一类为负数。假设数组的总和为`sum`，正数部分的和为`positiveNum`，那么负数部分的和就为`sum-positiveNum`，要保证`positiveNum - (sum - positiveNum) = target`，可以求得`positiveNum = (target + sum) / 2`。因此本题可以转化为得到`positiveNum`的方法有多少种。状态转移方程为`dp[j] += dp[j-nums[i]]`，表示在遍历到nums[i]时，有dp[j]种方法，不考虑nums[i]时，有dp[j-nums[i]]种方法，将所有方法累加即可。

## 474. 一和零

思路：将1和0的总个数分别看作二者背包的总容量，`dp[i][j][k]`表示在第i个字符串之前，1和0的个数满足m和n的子字符串个数。首先遍历字符串数组，统计当前字符串中1和0的个数，在不考虑0和1个数的情况下，**当前满足条件的子字符串一定与上一个子字符串相等**，即`dp[i][j][k] = dp[i-1][j][k]`。然后再考虑0和1的个数，如果可以装进背包，也就是二者个数分别小于j和k，则判断`dp[i-1][j][k]`和`dp[i-1][j-zero][k-one]+1`之间的最大值。

## 完全背包

思路：完全背包与0-1背包的区别在于完全背包中的物品可以放入无限次，因此只需要将0-1背包中遍历背包容量的顺序改为倒序就可以。并且遍历物品和背包循环的先后顺序可以颠倒，因为每个变化都是从左到右更新的。

## 518. 零钱兑换Ⅱ

思路：该题中数组dp理解物品**无限**的情况下，达到某个总和的方法个数。只需要将不同总和的方法累加，也就是`dp[j] += dp[j-nums[i]]`即可。

**注**：在本题中遍历物品和背包的先后顺序必须是先遍历物品，再遍历背包容量。如果反过来会得到物品的总**排列**数，也就是达到当前背包容量时，所有物品的全排列。

## 377. 组合总和Ⅳ

思路：该题在计算每个数字的组合数时，又同时计算组合中不同的排列方式。因此应该先遍历背包，再遍历物品，保证物品出现的顺序可以不同。

## 279. 完全平方数

思路：定义数组dp，预存目标数字前所有数字的完全平方数个数，`dp[i]`表示i的完全平方数的个数。每次更新只需要将j计算到$\sqrt i$即可，更新时取最小的个数。

**trick**：本题将目标数字作为背包容量，将平方数作为物品。

## 70. 爬楼梯

思路：如果题目改为一次可以爬1阶、2阶或m阶，那么该题就是完全背包，也就是累加每一级台阶的方法个数，并且先爬1阶再爬2阶和先爬2阶再爬1阶是两种方法。

## 322. 零钱兑换

思路：本题的硬币可以使用无限次，因此属于完全背包问题。总金额作为背包的总容量，不断更新`1~总金额`所需的**最少**硬币个数即可。因为是完全背包，所以遍历背包容量应该为正序，并且遍历背包和硬币的先后顺序不固定，因为每次都是计算**最小值**。

**注**：如果`dp[j-coins[i]]`还未**凑成**，也就是值为integer.MAX_VALUE，则跳过当前值，否则会影响取最小值。

## 139. 单词拆分

思路：把字符串看作背包，字符串中的字母看作物品。`dp[i]`表示前i-1个字母组成的单词是否在字典中。i从第1个字母开始遍历，至字符串的**长度+1**，j从0开始，遍历至i。如果dp[j]为true，且字典包含当前遍历的子字符串，也就是下标为[j, i-1]的字符串，则dp[i]也为true。

## 198. 打家劫舍

思路：题目要求闯入的房间不可以相邻，该条件约束状态转移方程的累加条件。也就是说，针对当前房间i，如果选择闯入当前房间，则偷窃金额为房间i-2的累加和加上房间i的金额；如果不闯入当前房间，则金额总和为房间i-1的金额。

## 213. 打家劫舍Ⅱ

思路：本题要求不可以同时闯入首尾房间。因此应该将闯入房间的区间分成两类：第一类可以闯入首房间，第二类可以闯入尾房间，在两类中取最大值。

**trick**：两类情况的代码类似，可以写成一个函数。

## 337. 打家劫舍Ⅲ

思路：需要先知道子树的状态，再决定根节点的选择，所以采用后序遍历。可以为每个节点建立一个长度为2的数组dp，第一个元素为偷当前节点的结果，第二个元素为不偷当前节点的结果。第一种情况偷当前节点，则两个子树都不能偷，所以`dp[0]=root.val + left[1] + right[1]`；第二种情况是不偷当前节点，则两个子树都可以偷，所以`dp[1] = max(left[0], left[1]) + max(right[0], right[1])`。

## 121. 买卖股票的最佳时机

思路：题目有两点要求，第一个是只允许买卖各一次；第二个是必须先买入才可以卖出。因此，每天的股票都可以对应是否买入以及是否卖出。可以将每天对应的持有状态使用两个标志位记录，即`dp[i][0]`表示持有股票，`dp[i][1]`表示不持有。如果第i天持有股票，对应前一天的状态可能是持有，也可能是不持有但在第i天买入；如果第i天不持有股票，对应前一天的状态可能是不持有，也有可能是持有但第i天卖出。

**注**：因为只允许买卖**一次**，所以前一天不持有股票但在第i天买入时，价格应该更新为`-prices[i]`。

## 122. 买卖股票的最佳时机Ⅱ

思路：本题允许买卖多次，因此与上一题的区别是如果i天持有股票，对应前一天的状态可能是持有，也有可能是不持有但在第i天买入，不同的是买入时，对应的价格为`dp[i-1][1] - prices[i]`

## 714. 买卖股票的最佳时机含手续费

思路：与上一题的区别只是加了手续费，因此计算利润时减去手续费即可。

**注**：只在买入或卖出时计算一次即可。

## 300. 最长递增子序列

思路：`dp[i]`表示前i个元素的递增子序列的最大长度，通过两个for循环，其中`j<i`，如果`nums[i]>nums[j]`，则将dp[i]更新为dp[j]+1，同时不断将dp[i]更新为最大值。最后取数组dp中的最大值即最长递增子序列。

# 674. 最长连续递增序列

思路：用数组dp记录递增序列的最大长度，因为题目要求是**连续递增**，所以遍历数组时，只需要与前一个元素比较即可。