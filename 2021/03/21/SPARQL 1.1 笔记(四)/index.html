<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon32.ico"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon16.ico"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"cherylqi.top",root:"/",scheme:"Gemini",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:"flat"},back2top:{enable:!0,sidebar:!1,scrollpercent:!0},bookmark:{enable:!0,color:"#222",save:"auto"},fancybox:!0,mediumzoom:!1,lazyload:!0,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!1,trigger:"auto",top_n_per_article:3,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}}}</script><meta name="description" content="18 SPARQL 的定义给定查询字符串和RDF数据集，本节定义了用于评估图形模式和解决方案修饰符的正确行为。这并不意味着SPARQL实现必须使用此处定义的过程。 执行SPARQL查询的结果由一系列步骤定义，从SPARQL查询作为字符串开始，将该字符串转换为抽象语法形式，然后将抽象语法转换为包含SPARQL代数运算符的SPARQL抽象查询。然后，在RDF数据集上评估此抽象查询。 18.1 初始定义"><meta property="og:type" content="article"><meta property="og:title" content="SPARQL 1.1 笔记(四)"><meta property="og:url" content="https://cherylqi.top/2021/03/21/SPARQL%201.1%20%E7%AC%94%E8%AE%B0(%E5%9B%9B)/index.html"><meta property="og:site_name" content="Cheryl Qi"><meta property="og:description" content="18 SPARQL 的定义给定查询字符串和RDF数据集，本节定义了用于评估图形模式和解决方案修饰符的正确行为。这并不意味着SPARQL实现必须使用此处定义的过程。 执行SPARQL查询的结果由一系列步骤定义，从SPARQL查询作为字符串开始，将该字符串转换为抽象语法形式，然后将抽象语法转换为包含SPARQL代数运算符的SPARQL抽象查询。然后，在RDF数据集上评估此抽象查询。 18.1 初始定义"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2021-03-21T08:28:44.000Z"><meta property="article:modified_time" content="2021-03-31T12:19:01.000Z"><meta property="article:author" content="Cheryl Qi"><meta property="article:tag" content="语义Web"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://cherylqi.top/2021/03/21/SPARQL%201.1%20%E7%AC%94%E8%AE%B0(%E5%9B%9B)/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>SPARQL 1.1 笔记(四) | Cheryl Qi</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">Cheryl Qi</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">自强不息，知行合一。</p></div><div class="site-nav-right"><div class="toggle popup-trigger"></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li></ul></nav></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><div class="reading-progress-bar"></div><a role="button" class="book-mark-link book-mark-link-fixed"></a><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://cherylqi.top/2021/03/21/SPARQL%201.1%20%E7%AC%94%E8%AE%B0(%E5%9B%9B)/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/profile.jpg"><meta itemprop="name" content="Cheryl Qi"><meta itemprop="description" content="Cheryl's Blog"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Cheryl Qi"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">SPARQL 1.1 笔记(四)</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-03-21 16:28:44" itemprop="dateCreated datePublished" datetime="2021-03-21T16:28:44+08:00">2021-03-21</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2021-03-31 20:19:01" itemprop="dateModified" datetime="2021-03-31T20:19:01+08:00">2021-03-31</time> </span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span id="busuanzi_value_page_pv"></span></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>12k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>23 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="18-SPARQL-的定义"><a href="#18-SPARQL-的定义" class="headerlink" title="18 SPARQL 的定义"></a>18 SPARQL 的定义</h2><p>给定查询字符串和RDF数据集，本节定义了用于评估图形模式和解决方案修饰符的正确行为。这并不意味着SPARQL实现必须使用此处定义的过程。</p><p>执行SPARQL查询的结果由一系列步骤定义，从SPARQL查询作为字符串开始，将该字符串转换为抽象语法形式，然后将抽象语法转换为包含SPARQL代数运算符的SPARQL抽象查询。然后，在RDF数据集上评估此抽象查询。</p><h3 id="18-1-初始定义"><a href="#18-1-初始定义" class="headerlink" title="18.1 初始定义"></a>18.1 初始定义</h3><h4 id="18-1-1-RDF-Terms"><a href="#18-1-1-RDF-Terms" class="headerlink" title="18.1.1 RDF Terms"></a>18.1.1 RDF Terms</h4><p>SPARQL是根据IRIs 定义的。IRIs是RDF URI引用的子集，它忽略了空格的使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Definition: RDF Term</span><br><span class="line">I是所有IRIs的集合.</span><br><span class="line">RDF-L是所有RDF Literals的集合</span><br><span class="line">RDF-B是RDF图中所有空节点的集合</span><br><span class="line">RDF Terms的集合, RDF-T, 是I ∪ RDF-L ∪ RDF-B.</span><br></pre></td></tr></table></figure><p><strong>RDF Term</strong>此定义从RDF数据模型收集了几个基本概念 ，但已更新为引用IRI而不是RDF URI引用。</p><span id="more"></span><h4 id="18-1-2-简单文字"><a href="#18-1-2-简单文字" class="headerlink" title="18.1.2 简单文字"></a>18.1.2 简单文字</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">简单的文字是所有没有语言标签或数据类型IRI的RDF文字集合</span><br></pre></td></tr></table></figure><h4 id="18-1-3-RDF数据集"><a href="#18-1-3-RDF数据集" class="headerlink" title="18.1.3 RDF数据集"></a>18.1.3 RDF数据集</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">一个RDF数据集是这样的集合：</span><br><span class="line">&#123; G, (&lt;u1&gt;, G1), (&lt;u2&gt;, G2), . . . (&lt;un&gt;, Gn) &#125;				//一个默认图和多个命名图</span><br><span class="line">其中，G和Gi是图，每一个&lt;ui&gt;是一个IRI。每一个&lt;ui&gt;是不同的。</span><br><span class="line">G是默认图。(&lt;ui&gt;, Gi) 是命名图。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">活动图：是数据集中用于与基本图模式匹配的图</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">RDF数据集合并</span><br><span class="line">有DS1 = &#123; G1, (&lt;u11&gt;, G11), (&lt;u12&gt;, G12), . . . (&lt;u1n&gt;, G1n) &#125;,</span><br><span class="line">DS2 = &#123; G2, (&lt;u21&gt;, G21), (&lt;u22&gt;, G22), . . . (&lt;u2m&gt;, G2m) &#125;</span><br><span class="line">然后定义关于DS1和DS2的RDF数据集的合并为：</span><br><span class="line">DS=&#123; G, (&lt;u1&gt;, G1), (&lt;u2&gt;, G2), . . . (&lt;uk&gt;, Gk) &#125;</span><br><span class="line">其中：</span><br><span class="line">N1是&#123; &lt;u1j&gt; j = 1 to n &#125;，N2是&#123; &lt;u2j&gt; j = 1 to m &#125;</span><br><span class="line"></span><br><span class="line">G是G1和G2的合并</span><br><span class="line">(&lt;ui&gt;, Gi) 是&lt;ui&gt;属于N1中但不属于N2</span><br><span class="line">(&lt;ui&gt;, Gi) 是&lt;ui&gt;属于N2中但不属于N1</span><br><span class="line">(&lt;ui&gt;, Gi) 是&lt;ui&gt;与N1中的&lt;uj&gt;相同，并且与N2中的&lt;uk&gt;相同。并且Gi是G1j和G2k的合并。</span><br></pre></td></tr></table></figure><h4 id="18-1-4-查询变量"><a href="#18-1-4-查询变量" class="headerlink" title="18.1.4 查询变量"></a>18.1.4 查询变量</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个查询变量是一个集合V中的成员，V来自RDF-T，是无限且不相交的。</span><br></pre></td></tr></table></figure><h4 id="18-1-5-三元组模式"><a href="#18-1-5-三元组模式" class="headerlink" title="18.1.5 三元组模式"></a>18.1.5 三元组模式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个三元组模式是这个集合的成员：(RDF-T ∪ V) x (I ∪ V) x (RDF-T ∪ V)</span><br></pre></td></tr></table></figure><p>三元组模式的定义包含文字主语，由于RDF图可能不包含文字主语，因此任何以文字为主语的SPARQL三元组模式都无法在任何RDF图上匹配。</p><h4 id="18-1-6-基本图模式"><a href="#18-1-6-基本图模式" class="headerlink" title="18.1.6 基本图模式"></a>18.1.6 基本图模式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个基本图模式是一个三元组模式集合</span><br></pre></td></tr></table></figure><p>空图模式是一个空集的三元组模式</p><h4 id="18-1-7-属性路径模式"><a href="#18-1-7-属性路径模式" class="headerlink" title="18.1.7 属性路径模式"></a>18.1.7 属性路径模式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">一个属性路径是一个三元组序列，ti属于序列ST，n = length(ST)-1，i从0到n，ti的宾语是与ti+1的主语相同的term。</span><br><span class="line">t0的主语是路径的起点</span><br><span class="line">tn的宾语是路径的终点</span><br><span class="line">如果每个ti都是G的一个三元组，则一个属性路径是图G中的一条路径</span><br></pre></td></tr></table></figure><p>一条属性路径不会跨越数据集中的多个图</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">属性路径表达式</span><br><span class="line">一个属性路径表达式是用上述格式中的属性路径的表达式</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">属性路径模式</span><br><span class="line">PP是所有路径表达式的集合。一个属性路径模式是该集合的成员：</span><br><span class="line">(RDF-T ∪ V) x PP x (RDF-T ∪ V)</span><br></pre></td></tr></table></figure><p>一条属性路径是一个三元组模式的概括，包括了属性位置的属性路径表达式。</p><h4 id="18-1-8-解决方案映射"><a href="#18-1-8-解决方案映射" class="headerlink" title="18.1.8 解决方案映射"></a>18.1.8 解决方案映射</h4><p>一个解决方案是一个从变量集到一个RDF Terms集的映射。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">解决方案映射</span><br><span class="line">一个解决方案映射，μ, 是一个局部函数μ : V -&gt; RDF-T.</span><br><span class="line">μ的定义域, dom(μ), 是在定义μ后V的子集。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">解决方案序列</span><br><span class="line">一个解决方案序列是一个解决方案列表，可能是无序的。</span><br></pre></td></tr></table></figure><p>使用由μ给定的变量，将expr（μ）写入表达式expr的值。评估可能会导致错误。</p><h4 id="18-1-9-解决方案序列修饰符"><a href="#18-1-9-解决方案序列修饰符" class="headerlink" title="18.1.9 解决方案序列修饰符"></a>18.1.9 解决方案序列修饰符</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- Order修饰符：按顺序排列解决方案</span><br><span class="line">- Projection修饰符：选择某些变量</span><br><span class="line">- Distinct修饰符：确保序列中的解决方案是唯一的</span><br><span class="line">- Reduce修饰语：允许消除一些不唯一的解决方案</span><br><span class="line">- Offset修改器：控制解决方案从整体解决方案序列中的位置开始</span><br><span class="line">- Limit修饰符：限制解决方案数量</span><br></pre></td></tr></table></figure><h4 id="18-1-10-SPARQL-查询"><a href="#18-1-10-SPARQL-查询" class="headerlink" title="18.1.10 SPARQL 查询"></a>18.1.10 SPARQL 查询</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">一个SPARQL抽象查询是一个元组（E,DS,QF）,其中：</span><br><span class="line">E 是一个SPARQL代数表达式</span><br><span class="line">DS 是一个RDF Dataset数据集</span><br><span class="line">QF 是一个查询形式</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">查询级别</span><br><span class="line">一个查询级别是一个图模式，一组组和聚合以及一组解决方案修饰符。</span><br></pre></td></tr></table></figure><p><u>查询是一棵“查询级别”的树，其中每个子查询在树中形成一个查询级别。</u></p><h3 id="18-2-转化为SPARQL代数"><a href="#18-2-转化为SPARQL代数" class="headerlink" title="18.2 转化为SPARQL代数"></a>18.2 转化为SPARQL代数</h3><p>本部分定义了将SPARQL查询字符串中的图形模式和解决方案修饰符转换为SPARQL代数表达式的过程。所描述的过程转换了嵌套查询的一级，该嵌套由子查询使用嵌套的<code>SELECT</code>语法形成， 并递归应用于子查询。每个级别都包括图形模式匹配和过滤，然后应用解决方案修饰符。</p><p>解析SPARQL查询字符串，并应用第4节中给出的IRI和三元组模式的缩写 。此时，抽象语法树由以下内容组成：</p><div class="table-container"><table><thead><tr><th>Patterns</th><th>Modifiers</th><th>Query Forms</th><th>Other</th></tr></thead><tbody><tr><td>RDF terms</td><td>DISTINCT</td><td>SELECT</td><td>VALUES</td></tr><tr><td>Property path expression</td><td>REDUCED</td><td>CONSTRUCT</td><td>SERVICE</td></tr><tr><td>Property path patterns</td><td>Projection</td><td>DESCRIBE</td><td></td></tr><tr><td>Groups</td><td>ORDER BY</td><td>ASK</td><td></td></tr><tr><td>OPTIONAL</td><td>LIMIT</td><td></td><td></td></tr><tr><td>UNION</td><td>OFFSET</td><td></td><td></td></tr><tr><td>GRAPH</td><td>Select expressions</td><td></td><td></td></tr><tr><td>BIND</td><td></td><td></td><td></td></tr><tr><td>GROUP BY</td><td></td><td></td><td></td></tr><tr><td>HAVING</td><td></td><td></td><td></td></tr><tr><td>MINUS</td><td></td><td></td><td></td></tr><tr><td>FILTER</td><td></td><td></td></tr></tbody></table></div><p>转换此类抽象语法树的结果是一个SPARQL查询，该查询在SPARQL代数中使用以下符号：</p><div class="table-container"><table><thead><tr><th>Graph Pattern</th><th>Solution Modifiers</th><th>Property Path</th></tr></thead><tbody><tr><td>BGP</td><td>ToList</td><td>PredicatePath</td></tr><tr><td>Join</td><td>OrderBy</td><td>InversePath</td></tr><tr><td>LeftJoin</td><td>Project</td><td>SequencePath</td></tr><tr><td>Filter</td><td>Distinct</td><td>AlernativePath</td></tr><tr><td>Union</td><td>Reduced</td><td>ZeroOrMorePath</td></tr><tr><td>Graph</td><td>Slice</td><td>OneOrMorePath</td></tr><tr><td>Extend</td><td>ToMultiSet</td><td>ZeroOrOnePath</td></tr><tr><td>Minus</td><td></td><td>NegatedPropertySet</td></tr><tr><td>Group</td><td></td><td></td></tr><tr><td>Aggregation</td><td></td><td></td></tr><tr><td>AggregateJoin</td><td></td></tr></tbody></table></div><p><em>切片</em>是OFFSET和LIMIT的组合。</p><p><em>ToList</em>用于发生从图形模式匹配结果到序列的转换的情况。</p><p><em>ToMultiSet</em>用于发生从解决方案序列到多集的转换的情况。</p><h4 id="18-2-1-变量作用域"><a href="#18-2-1-变量作用域" class="headerlink" title="18.2.1 变量作用域"></a>18.2.1 变量作用域</h4><p>在执行查询的SPARQL代数时，如果有一种方法可以使变量位于解决方案映射的定义域中，则可以将其定义为<em>作用域内</em>的变量。下面的定义提供了一种从查询的抽象语法确定这一点的方法。</p><p>注意，<u>带有投影的子查询可以隐藏变量</u>。在<code>FILTER</code>或<code>MINUS</code>中的变量不会导致变量超出这些形式的范围。</p><p>令<strong>P</strong>，<strong>P1</strong>，<strong>P2</strong>为图形模式，让<strong>E</strong>，<strong>E1</strong>，… <strong>En</strong>为表达式。在以下情况下，变量<code>v</code>在作用域内：</p><div class="table-container"><table><thead><tr><th>Syntax Form</th><th>In-scope variables</th></tr></thead><tbody><tr><td>Basic Graph Pattern (BGP)</td><td><code>v</code> occurs in the BGP</td></tr><tr><td>Path</td><td><code>v</code> occurs in the path</td></tr><tr><td>Group <code>&#123; P1 P2 ... &#125;</code></td><td><code>v</code> is in-scope 在一个多个图中 P1, P2, …</td></tr><tr><td><code>GRAPH term &#123; P &#125;</code></td><td><code>v</code> is <code>term</code> or <code>v</code> is in-scope in P</td></tr><tr><td><code>&#123; P1 &#125; UNION &#123; P2 &#125;</code></td><td><code>v</code> is in-scope in P1 or in-scope in P2</td></tr><tr><td><code>OPTIONAL &#123;P&#125;</code></td><td><code>v</code> is in-scope in P</td></tr><tr><td><code>SERVICE term &#123;P&#125;</code></td><td><code>v</code> is <code>term</code> or <code>v</code> is in-scope in P</td></tr><tr><td><code>BIND (expr AS v)</code></td><td><code>v</code> is in-scope</td></tr><tr><td><code>SELECT .. v .. &#123; P &#125;</code></td><td><code>v</code> is in-scope</td></tr><tr><td><code>SELECT ... (expr AS v)</code></td><td><code>v</code> is in-scope</td></tr><tr><td><code>GROUP BY (expr AS v)</code></td><td><code>v</code> is in-scope</td></tr><tr><td><code>SELECT * &#123; P &#125;</code></td><td><code>v</code> is in-scope in <code>P</code></td></tr><tr><td><code>VALUES v &#123; values &#125;</code></td><td><code>v</code> is in-scope</td></tr><tr><td><code>VALUES varlist &#123; values &#125;</code></td><td><code>v</code> is in-scope if <code>v</code> is in <code>varlist</code></td></tr></tbody></table></div><p>变量<code>v</code>一定不能在<code>(expr AS v)</code> 形式的作用域内。<code>(expr AS v)</code>的作用域适用于 <code>SELECT</code>表达式。</p><p><code>BIND (expr AS v)</code>要求变量<code>v</code>不在使用它的组图模式中的先前元素范围内。</p><p>在<code>SELECT</code>中，该变量<code>v</code>不在该<code>SELECT</code>子句的图形模式作用域内，也不得在该子句前面的另一个select表达式中使用。</p><h4 id="18-2-2-转换图形模式"><a href="#18-2-2-转换图形模式" class="headerlink" title="18.2.2 转换图形模式"></a>18.2.2 转换图形模式</h4><p>本节描述了将SPARQL图形模式转换为SPARQL<strong>代数表达式</strong>的过程。此过程将应用于形成<code>WHERE</code>查询子句的组图模式（定界符<code>&#123;...&#125;</code>之间的单元），并递归应用于组图模式内的每个语法元素。转换的结果是SPARQL代数表达式。</p><p>概括而言，这些步骤的应用如下：</p><ul><li>扩展 IRI，文字和三元组模式的语法形式。</li><li>转换属性路径表达式</li><li>将一些属性路径模式转换为三元组</li><li>将<code>FILTER</code>s收集到组中</li><li>翻译基本图形模式</li><li>翻译组中其余的图形模式</li><li>添加过滤器</li><li>简化代数表达</li></ul><p>translate(graph pattern)此处描述的算法可转换图模式</p><h5 id="18-2-2-1-扩展语法形式"><a href="#18-2-2-1-扩展语法形式" class="headerlink" title="18.2.2.1 扩展语法形式"></a>18.2.2.1 扩展语法形式</h5><p>扩展第4节中给出的IRI和三元组模式的缩写 。</p><h5 id="18-2-2-2-收集FILTER元素"><a href="#18-2-2-2-收集FILTER元素" class="headerlink" title="18.2.2.2 收集FILTER元素"></a>18.2.2.2 收集<code>FILTER</code>元素</h5><p><code>FILTER</code>表达式适用于它们出现的<strong>整个</strong>组图模式。在转换每个组元素后，将用于执行过滤的代数运算符添加到该组。我们在这里将过滤器收集在一起，并将其从组中删除，然后将其应用于整个转换后的组图模式。</p><p>在此步骤中，我们还将转换含有<code>FILTER</code> 表达式<code>EXISTS</code>和<code>NOT EXISTS</code>的图形模式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Let FS := empty set</span><br><span class="line"></span><br><span class="line">For each form FILTER(expr) in the group graph pattern:</span><br><span class="line">    In expr, replace NOT EXISTS&#123;P&#125; with fn:not(exists(translate(P))) </span><br><span class="line">    In expr, replace EXISTS&#123;P&#125; with exists(translate(P))</span><br><span class="line">    FS := FS ∪ &#123;expr&#125;</span><br><span class="line">    End</span><br></pre></td></tr></table></figure><h5 id="18-2-2-3-转换属性路径表达式"><a href="#18-2-2-3-转换属性路径表达式" class="headerlink" title="18.2.2.3 转换属性路径表达式"></a>18.2.2.3 转换属性路径表达式</h5><p>下表提供了从SPARQL语法到SPARQL代数中的术语的属性路径表达式的转换。这将递归地应用于属性路径表达式的所有元素。</p><p>此步骤之后的下一步将某些形式转换为三元组模式，然后通过邻接（无中间组模式定界符<code>&#123;</code>和<code>&#125;</code>） 或其他语法形式将其转换为基本图形模式。总体而言，仅IRI的SPARQL语法属性路径变为三元组模式，并将它们聚合为基本图形模式。</p><p>笔记：</p><ul><li>否定的属性集中形式IRI和^ IRI的顺序不相关。</li></ul><p>我们引入以下符号：</p><ul><li>link</li><li>inv</li><li>alt</li><li>seq</li><li>ZeroOrMorePath</li><li>OneOrMorePath</li><li>ZeroOrOnePath</li><li>NPS (for NegatedPropertySet)</li></ul><div class="table-container"><table><thead><tr><th>Syntax Form (path)</th><th>Algebra (path)</th></tr></thead><tbody><tr><td><code>iri</code></td><td><code>link(iri)</code></td></tr><tr><td><code>^path</code></td><td><code>inv(path)</code></td></tr><tr><td>`!(:iri1</td><td>…</td><td>:irin)`</td><td><code>NPS(&#123;:iri1 ... :irin&#125;)</code></td></tr><tr><td>`!(^:iri1</td><td>…</td><td>^:irin)`</td><td><code>inv(NPS(&#123;:iri1 ... :irin&#125;))</code></td></tr><tr><td>`!(:iri1</td><td>…</td><td>:irii</td><td>^:irii+1</td><td>…</td><td>^:irim)`</td><td><code>alt(NPS(&#123;:iri1 ...:irii&#125;), inv(NPS(&#123;:irii+1, ..., :irim&#125;)) )</code></td></tr><tr><td><code>path1 / path2</code></td><td><code>seq(path1, path2)</code></td></tr><tr><td>`path1</td><td>path2`</td><td><code>alt(path1, path2)</code></td></tr><tr><td><code>path*</code></td><td><code>ZeroOrMorePath(path)</code></td></tr><tr><td><code>path+</code></td><td><code>OneOrMorePath(path)</code></td></tr><tr><td><code>path?</code></td><td><code>ZeroOrOnePath(path)</code></td></tr></tbody></table></div><h5 id="18-2-2-4-转换属性路径模式"><a href="#18-2-2-4-转换属性路径模式" class="headerlink" title="18.2.2.4 转换属性路径模式"></a>18.2.2.4 转换属性路径模式</h5><p>上一步转换了属性路径表达式。此步骤将属性路径模式转换为三元组模式，或将其作为主语端点，属性路径表达式和宾语端点转换为通用代数运算，以进行路径评估。</p><p>笔记：</p><ul><li>X and Y are RDF terms or variables.</li><li>?V is a fresh variable.</li><li>P and Q are path expressions.</li><li>These are only applied to property path patterns, not within property path expressions.</li><li>Translations earlier in the table are applied in preference to the last translation.</li><li>The final translation simply wraps any remaining property path expression to use a common form <code>Path(...)</code>.</li></ul><div class="table-container"><table><thead><tr><th>Algebra (path)</th><th>Translation</th></tr></thead><tbody><tr><td><code>X link(iri) Y</code></td><td><code>X iri Y</code></td></tr><tr><td><code>X inv(iri) Y</code></td><td><code>Y iri X</code></td></tr><tr><td><code>X seq(P, Q) Y</code></td><td><code>X P ?V . ?V Q P</code></td></tr><tr><td><code>X P Y</code></td><td><code>Path(X, P, Y)</code></td></tr></tbody></table></div><p>整个路径转换过程的示例（<code>?_V</code>是一个新变量）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">?s :p/:q ?o</span><br><span class="line"></span><br><span class="line">?s :p ?_V .</span><br><span class="line">?_V :q ?o</span><br><span class="line"></span><br><span class="line">?s :p* ?o</span><br><span class="line"></span><br><span class="line">Path(?s, ZeroOrMorePath(link(:p)), ?o)</span><br><span class="line"></span><br><span class="line">:list rdf:rest*/rdf:first ?member</span><br><span class="line"></span><br><span class="line">Path(:list, ZeroOrMorePath(link(rdf:rest)), ?_V) .</span><br><span class="line">?_V rdf:first ?member</span><br></pre></td></tr></table></figure><h5 id="18-2-2-5-转换基本图形模式"><a href="#18-2-2-5-转换基本图形模式" class="headerlink" title="18.2.2.5 转换基本图形模式"></a>18.2.2.5 转换基本图形模式</h5><p>在转换属性路径后，将所有相邻的三元组模式收集在一起以形成基本图形模式<code>BGP(triples)</code>。</p><h5 id="18-2-2-6-转换图形模式"><a href="#18-2-2-6-转换图形模式" class="headerlink" title="18.2.2.6 转换图形模式"></a>18.2.2.6 转换图形模式</h5><p>接下来，我们转换每一个剩余的图模式，递归的应用转换过程</p><p>如果形式为是GroupOrUnionGraphPattern</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Let A := undefined</span><br><span class="line">          </span><br><span class="line">For each element G in the GroupOrUnionGraphPattern</span><br><span class="line">    If A is undefined</span><br><span class="line">        A := Translate(G)</span><br><span class="line">    Else</span><br><span class="line">        A := Union(A, Translate(G))</span><br><span class="line">    End</span><br><span class="line"></span><br><span class="line">The result is A</span><br></pre></td></tr></table></figure><p>如果形式为GraphGraphPattern</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">If the form is GRAPH IRI GroupGraphPattern</span><br><span class="line">    The result is Graph(IRI, Translate(GroupGraphPattern))</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">If the form is GRAPH Var GroupGraphPattern</span><br><span class="line">    The result is Graph(Var, Translate(GroupGraphPattern))</span><br></pre></td></tr></table></figure><p>如果形式为GroupGraphPattern</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Let FS := the empty set</span><br><span class="line">Let G := the empty pattern, a basic graph pattern which is the empty set.</span><br><span class="line"></span><br><span class="line">For each element E in the GroupGraphPattern</span><br><span class="line"></span><br><span class="line">    If E is of the form OPTIONAL&#123;P&#125; </span><br><span class="line">        Let A := Translate(P)</span><br><span class="line">        If A is of the form Filter(F, A2)</span><br><span class="line">            G := LeftJoin(G, A2, F)</span><br><span class="line">        Else </span><br><span class="line">            G := LeftJoin(G, A, true)</span><br><span class="line">            End</span><br><span class="line">        End</span><br><span class="line"></span><br><span class="line">    If E is of the form MINUS&#123;P&#125;</span><br><span class="line">        G := Minus(G, Translate(P))</span><br><span class="line">        End</span><br><span class="line"></span><br><span class="line">    If E is of the form BIND(expr AS var)</span><br><span class="line">        G := Extend(G, var, expr)</span><br><span class="line">        End</span><br><span class="line"></span><br><span class="line">    If E is any other form </span><br><span class="line">        Let A := Translate(E)</span><br><span class="line">        G := Join(G, A)</span><br><span class="line">        End</span><br><span class="line"></span><br><span class="line">   End</span><br><span class="line">   </span><br><span class="line">The result is G.</span><br><span class="line">            </span><br></pre></td></tr></table></figure><p>如果形式为InlineData</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The result is a multiset of solution mappings &#x27;data&#x27;.</span><br></pre></td></tr></table></figure><p>通过从变量列表（或单个变量）中相应位置的变量形成一个解决方案映射来形成<em>数据</em>，如果<code>BindingValue</code>是单词<code>UNDEF</code>，则省略绑定。</p><p>如果形式是SubSelect</p><h5 id="18-2-2-7-组过滤器"><a href="#18-2-2-7-组过滤器" class="headerlink" title="18.2.2.7 组过滤器"></a>18.2.2.7 组过滤器</h5><p>在转换组之后，将添加过滤器表达式，以便将它们应用于该组的其余所有部分：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">If FS is not empty</span><br><span class="line">    Let G := output of preceding step</span><br><span class="line">    Let X := Conjunction of expressions in FS</span><br><span class="line">    G := Filter(X, G)</span><br><span class="line">    End</span><br></pre></td></tr></table></figure><h5 id="18-2-2-8-简化步骤"><a href="#18-2-2-8-简化步骤" class="headerlink" title="18.2.2.8 简化步骤"></a>18.2.2.8 简化步骤</h5><p>一个图形模式的一些组变为<code>join(Z, A)</code>，其中Z是空的基本图形模式（这是空集）。可以用A代替它们。空图模式Z是连接的标识：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Replace join(Z, A) by A</span><br><span class="line">Replace join(A, Z) by A</span><br></pre></td></tr></table></figure><h4 id="18-2-3-映射图模式的示例"><a href="#18-2-3-映射图模式的示例" class="headerlink" title="18.2.3 映射图模式的示例"></a>18.2.3 映射图模式的示例</h4><p>重写示例的第二种形式是第一种形式，其中空组联接已通过简化步骤删除。</p><p>示例：由单个三元模式组成的基本图形模式的组：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123; ?s ?p ?o &#125;</span><br><span class="line"></span><br><span class="line">Join(Z, BGP(?s ?p ?o) )</span><br><span class="line">BGP(?s ?p ?o)</span><br></pre></td></tr></table></figure><p>示例：由两个三元组模式组成的基本图形模式的组：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; ?s :p1 ?v1 ; :p2 ?v2 &#125;</span><br><span class="line"></span><br><span class="line">BGP( ?s :p1 ?v1 . ?s :p2 ?v2 )</span><br></pre></td></tr></table></figure><p>示例：由两个基本图形模式的并集组成的组：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123; &#123; ?s :p1 ?v1 &#125; UNION &#123;?s :p2 ?v2 &#125; &#125;</span><br><span class="line"></span><br><span class="line">Union(Join(Z, BGP(?s :p1 ?v1)),</span><br><span class="line">      Join(Z, BGP(?s :p2 ?v2)) )</span><br><span class="line">      </span><br><span class="line">Union( BGP(?s :p1 ?v1) , BGP(?s :p2 ?v2) )</span><br></pre></td></tr></table></figure><p>示例：由联合和基本图形模式的联合组成的组：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123; &#123; ?s :p1 ?v1 &#125; UNION &#123;?s :p2 ?v2 &#125; UNION &#123;?s :p3 ?v3 &#125; &#125;</span><br><span class="line"></span><br><span class="line">Union(</span><br><span class="line">    Union( Join(Z, BGP(?s :p1 ?v1)),</span><br><span class="line">           Join(Z, BGP(?s :p2 ?v2))) ,</span><br><span class="line">    	   Join(Z, BGP(?s :p3 ?v3)) )</span><br><span class="line">    </span><br><span class="line">Union(</span><br><span class="line">    Union( BGP(?s :p1 ?v1) ,</span><br><span class="line">           BGP(?s :p2 ?v2),</span><br><span class="line">    	   BGP(?s :p3 ?v3))</span><br></pre></td></tr></table></figure><p>示例：由基本图形模式和可选图形模式组成的组：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123; ?s :p1 ?v1 OPTIONAL &#123;?s :p2 ?v2 &#125; &#125;</span><br><span class="line"></span><br><span class="line">LeftJoin(</span><br><span class="line">    Join(Z, BGP(?s :p1 ?v1)),</span><br><span class="line">    Join(Z, BGP(?s :p2 ?v2)),true)</span><br><span class="line">    </span><br><span class="line">LeftJoin(BGP(?s :p1 ?v1), BGP(?s :p2 ?v2), true)</span><br></pre></td></tr></table></figure><p>示例：由基本图形模式和两个可选图形模式组成的组：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123; ?s :p1 ?v1 OPTIONAL &#123;?s :p2 ?v2 &#125; OPTIONAL &#123; ?s :p3 ?v3 &#125; &#125;</span><br><span class="line"></span><br><span class="line">LeftJoin(</span><br><span class="line">    LeftJoin(</span><br><span class="line">        BGP(?s :p1 ?v1),</span><br><span class="line">        BGP(?s :p2 ?v2),</span><br><span class="line">        true) ,</span><br><span class="line">    BGP(?s :p3 ?v3),</span><br><span class="line">    true)</span><br></pre></td></tr></table></figure><p>示例：由基本图形模式和带有过滤器的可选图形模式组成的组：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123; ?s :p1 ?v1 OPTIONAL &#123;?s :p2 ?v2 FILTER(?v1&lt;3) &#125; &#125;</span><br><span class="line"></span><br><span class="line">LeftJoin(</span><br><span class="line">     Join(Z, BGP(?s :p1 ?v1)),</span><br><span class="line">     Join(Z, BGP(?s :p2 ?v2)),</span><br><span class="line">     (?v1&lt;3) )</span><br><span class="line">     </span><br><span class="line">LeftJoin(</span><br><span class="line">    BGP(?s :p1 ?v1) ,</span><br><span class="line">    BGP(?s :p2 ?v2) ,</span><br><span class="line">   (?v1&lt;3) )</span><br></pre></td></tr></table></figure><p>示例：由联合图模式和可选图模式组成的组：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123; &#123;?s :p1 ?v1&#125; UNION &#123;?s :p2 ?v2&#125; OPTIONAL &#123;?s :p3 ?v3&#125; &#125;</span><br><span class="line"></span><br><span class="line">LeftJoin(</span><br><span class="line">  Union(BGP(?s :p1 ?v1),</span><br><span class="line">        BGP(?s :p2 ?v2)) ,</span><br><span class="line">  BGP(?s :p3 ?v3) ,</span><br><span class="line">  true )</span><br></pre></td></tr></table></figure><p>示例：由基本图形模式，过滤器和可选图形模式组成的组：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123; ?s :p1 ?v1 FILTER (?v1 &lt; 3 ) OPTIONAL &#123;?s :p2 ?v2&#125; &#125;</span><br><span class="line"></span><br><span class="line">Filter( ?v1 &lt; 3 ,</span><br><span class="line">  LeftJoin( BGP(?s :p1 ?v1), BGP(?s :p2 ?v2), true) ,</span><br><span class="line">  )</span><br></pre></td></tr></table></figure><p>示例：涉及BIND的模式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123; ?s :p ?v . BIND (2*?v AS ?v2) ?s :p1 ?v2 &#125;</span><br><span class="line"></span><br><span class="line">Join(</span><br><span class="line">   Extend( BGP(?s :p ?v), ?v2, 2*?v) ,</span><br><span class="line">   BGP(?s :p1 ?v2) )</span><br></pre></td></tr></table></figure><p>示例：涉及BIND的模式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123; ?s :p ?v . &#123;&#125; BIND (2*?v AS ?v2) &#125;</span><br><span class="line"></span><br><span class="line">Join(</span><br><span class="line">   BGP(?s :p ?v), ?v2, 2*?v) ,</span><br><span class="line">   Extend(&#123;&#125;, ?v2, 2*?v)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>示例：涉及MINUS的模式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123; ?s :p ?v . MINUS &#123;?s :p1 ?v2 &#125; &#125;</span><br><span class="line"></span><br><span class="line">Minus(</span><br><span class="line">   BGP(?s :p ?v)</span><br><span class="line">   BGP(?s :p1 ?v2))</span><br></pre></td></tr></table></figure><p>示例：涉及子查询的模式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123; ?s :p ?o . &#123;SELECT DISTINCT ?o &#123;?o ?p ?z&#125; &#125; &#125;</span><br><span class="line"></span><br><span class="line">Join(</span><br><span class="line">   BGP(?s :p ?o) ,</span><br><span class="line">   ToMultiSet(</span><br><span class="line">     Distinct(Project(BGP(?o ?p ?z), &#123;?o&#125;)) )</span><br><span class="line">   )</span><br></pre></td></tr></table></figure><h4 id="18-2-4-转换组，集合，HAVING，最终VALUES子句和SELECT表达式"><a href="#18-2-4-转换组，集合，HAVING，最终VALUES子句和SELECT表达式" class="headerlink" title="18.2.4 转换组，集合，HAVING，最终VALUES子句和SELECT表达式"></a>18.2.4 转换组，集合，HAVING，最终VALUES子句和SELECT表达式</h4><p>在此步骤中，我们按以下顺序在查询级别处理子句：</p><ul><li>Grouping</li><li>Aggregates</li><li>HAVING</li><li>VALUES</li><li>Select expressions</li></ul><h5 id="18-2-4-1-分组和聚合"><a href="#18-2-4-1-分组和聚合" class="headerlink" title="18.2.4.1 分组和聚合"></a>18.2.4.1 分组和聚合</h5><p>步骤：GROUP BY</p><p>如果使用了<code>GROUP BY</code>关键字，或者由于在投影中使用了聚合，则存在隐式分组，则分组由Group函数执行。它将解决方案集分为一个或多个解决方案的组，且总体基数相同。在隐式分组的情况下，使用固定常数（1）将所有解决方案分组为一个组。</p><p>步骤：Aggregates</p><p>聚合步骤被应用为查询级别上的转换，用Aggregation（）代数表达式替换了查询级别中的聚合表达式。</p><p>下面给出了使用任何聚合的查询级别的转换：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">Let A := the empty sequence</span><br><span class="line">Let Q := the query level being evaluated</span><br><span class="line">Let P := the algebra translation of the GroupGraphPattern of the query level</span><br><span class="line">Let E := [], a list of pairs of the form (variable, expression)</span><br><span class="line"></span><br><span class="line">If Q contains GROUP BY exprlist</span><br><span class="line">   Let G := Group(exprlist, P)</span><br><span class="line">Else If Q contains an aggregate in SELECT, HAVING, ORDER BY</span><br><span class="line">   Let G := Group((1), P)</span><br><span class="line">Else</span><br><span class="line">   skip the rest of the aggregate step</span><br><span class="line">   End</span><br><span class="line"></span><br><span class="line">Global i := 1   # Initially 1 for each query processed</span><br><span class="line"></span><br><span class="line">For each (X AS Var) in SELECT, each HAVING(X), and each ORDER BY X in Q</span><br><span class="line">  For each unaggregated variable V in X</span><br><span class="line">      Replace V with Sample(V)</span><br><span class="line">      End</span><br><span class="line">  For each aggregate R(args ; scalarvals) now in X</span><br><span class="line">      # note scalarvals may be omitted, then it&#x27;s equivalent to the empty set</span><br><span class="line">      Ai := Aggregation(args, R, scalarvals, G)</span><br><span class="line">      Replace R(...) with aggi in Q</span><br><span class="line">      i := i + 1</span><br><span class="line">      End</span><br><span class="line">  End</span><br><span class="line"></span><br><span class="line">For each variable V appearing outside of an aggregate</span><br><span class="line">   Ai := Aggregation(V, Sample, &#123;&#125;, G)</span><br><span class="line">   E := E append (V, aggi)</span><br><span class="line">   i := i + 1</span><br><span class="line">   End</span><br><span class="line"></span><br><span class="line">A := Ai, ..., Ai-1</span><br><span class="line">P := AggregateJoin(A)</span><br></pre></td></tr></table></figure><p>注意：agg i是一个临时变量。然后在18.2.4.4中将E用于选择表达式的处理。</p><p><strong>示例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PREFIX rdf: &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt;</span><br><span class="line">SELECT (SUM(?val) AS ?sum) (COUNT(?a) AS ?count)</span><br><span class="line">WHERE &#123;</span><br><span class="line">  ?a rdf:value ?val .</span><br><span class="line">&#125; GROUP BY ?a</span><br></pre></td></tr></table></figure><p>SUM表达式变为agg 1，而COUNT表达式变为agg 2。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Let G := Group((?a), BGP(?a rdf:value ?val))</span><br><span class="line">A1 = Aggregation((?val), Sum, &#123;&#125;, G)</span><br><span class="line">A2 = Aggregation((?a), Count, &#123;&#125;, G)</span><br><span class="line">A := (A1, A2)</span><br><span class="line">Let P := AggregateJoin(A)</span><br></pre></td></tr></table></figure><h5 id="18-2-4-2-HAVING"><a href="#18-2-4-2-HAVING" class="headerlink" title="18.2.4.2 HAVING"></a>18.2.4.2 HAVING</h5><p>使用与FILTER（）相同的规则评估HAVING表达式。请注意，由于在评估HAVING子句的逻辑位置，因此SELECT子句投影的表达式对HAVING子句不可见。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Let Q := the query level being evaluated</span><br><span class="line">Let P := the algebra translation of the query level so far</span><br><span class="line"></span><br><span class="line">For each HAVING(E) in Q</span><br><span class="line">    P := Filter(E, P)</span><br><span class="line">    End</span><br></pre></td></tr></table></figure><h5 id="18-2-4-3-VALUES"><a href="#18-2-4-3-VALUES" class="headerlink" title="18.2.4.3 VALUES"></a>18.2.4.3 VALUES</h5><p>如果查询具有结尾的VALUES子句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Let P := the algebra translation of the query level so far</span><br><span class="line">P := Join(P, ToMultiSet(data))</span><br><span class="line">  where data is a solution sequence formed from the VALUES clause</span><br></pre></td></tr></table></figure><p>数据的转换与内联数据的转换相同。</p><h5 id="18-2-4-4-SELECT表达式"><a href="#18-2-4-4-SELECT表达式" class="headerlink" title="18.2.4.4 SELECT表达式"></a>18.2.4.4 SELECT表达式</h5><p>Step: Select expressions</p><p>我们有两种形式的抽象语法要考虑：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">SELECT selItem ... &#123; pattern &#125;</span><br><span class="line">SELECT * &#123; pattern &#125;</span><br><span class="line"></span><br><span class="line">Let X := algebra from earlier steps</span><br><span class="line">Let VS := list of all variables visible in the pattern,</span><br><span class="line">           so restricted by sub-SELECT projected variables and GROUP BY variables.</span><br><span class="line">           Not visible: only in filter, exists/not exists, masked by a subselect, </span><br><span class="line">                        non-projected GROUP variables, only in the right hand side of MINUS</span><br><span class="line"></span><br><span class="line">Let PV := &#123;&#125;, a set of variable names</span><br><span class="line">Note, E is a list of pairs of the form (variable, expression), defined in section 18.2.4</span><br><span class="line">  </span><br><span class="line">If &quot;SELECT *&quot;</span><br><span class="line">    PV := VS</span><br><span class="line"></span><br><span class="line">If  &quot;SELECT selItem ...:&quot;  </span><br><span class="line">    For each selItem:</span><br><span class="line">        If selItem is a variable</span><br><span class="line">            PV := PV ∪ &#123; variable &#125;</span><br><span class="line">        End</span><br><span class="line">        If selItem is (expr AS variable)</span><br><span class="line">            variable must not appear in VS nor in PV; if it does then generate a syntax error and stop</span><br><span class="line">            PV := PV ∪ &#123; variable &#125;</span><br><span class="line">            E := E append (variable, expr) </span><br><span class="line">        End</span><br><span class="line">    End</span><br><span class="line"></span><br><span class="line">For each pair (var, expr) in E</span><br><span class="line">    X := Extend(X, var, expr)</span><br><span class="line">    End</span><br><span class="line">  </span><br><span class="line">Result is X  </span><br><span class="line">The set PV is used later for projection.</span><br><span class="line">            </span><br></pre></td></tr></table></figure><p>当将变量用作SELECT的WHERE子句内部或已在此SELECT表达式中用作AS的变量时，将变量用作AS的命名目标（例如… AS？x）会出现语法错误。</p><h4 id="18-2-5-转换解决方案修饰符"><a href="#18-2-5-转换解决方案修饰符" class="headerlink" title="18.2.5 转换解决方案修饰符"></a>18.2.5 转换解决方案修饰符</h4><p>解决方案修饰符适用于模式匹配后对SPARQL查询的处理。解决方案修饰符按以下顺序应用于查询：</p><ul><li>Order by</li><li>Projection</li><li>Distinct</li><li>Reduced</li><li>Offset</li><li>Limit</li></ul><p>步骤：ToList</p><p>ToList将一个多集转换为具有相同元素和基数的序列。该序列没有隐含的顺序；重复项不必相邻。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Let M := ToList(Pattern)</span><br></pre></td></tr></table></figure><h5 id="18-2-5-1-ORDER-BY"><a href="#18-2-5-1-ORDER-BY" class="headerlink" title="18.2.5.1 ORDER BY"></a>18.2.5.1 ORDER BY</h5><p>如果查询字符串具有ORDER BY子句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">M := OrderBy(M, list of order comparators)</span><br></pre></td></tr></table></figure><h5 id="18-2-5-2-Projection"><a href="#18-2-5-2-Projection" class="headerlink" title="18.2.5.2 Projection"></a>18.2.5.2 Projection</h5><p><code>PV</code>在SELECT表达式的处理中计算了一组投影变量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">M := Project(M, PV)</span><br></pre></td></tr></table></figure><p>其中vars是SELECT子句中提到的变量集，或者 如果使用SELECT *，则是查询范围内的所有命名变量。</p><h5 id="18-2-5-3-DISTINCT"><a href="#18-2-5-3-DISTINCT" class="headerlink" title="18.2.5.3 DISTINCT"></a>18.2.5.3 DISTINCT</h5><p>如果查询包含DISTINCT</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">M := Distinct(M)</span><br></pre></td></tr></table></figure><h5 id="18-2-5-4-REDUCED"><a href="#18-2-5-4-REDUCED" class="headerlink" title="18.2.5.4 REDUCED"></a>18.2.5.4 REDUCED</h5><p>如果查询包含REDUCED</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">M := Reduced(M)</span><br></pre></td></tr></table></figure><h5 id="18-2-5-5-OFFSET-and-LIMIT"><a href="#18-2-5-5-OFFSET-and-LIMIT" class="headerlink" title="18.2.5.5 OFFSET and LIMIT"></a>18.2.5.5 OFFSET and LIMIT</h5><p>如果查询包含”OFFSET start” or “LIMIT length”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">M := Slice(M, start, length)</span><br><span class="line"></span><br><span class="line">start defaults to 0</span><br><span class="line"></span><br><span class="line">length defaults to (size(M)-start).</span><br></pre></td></tr></table></figure><h5 id="18-2-5-6-Final-Algebra-Expression"><a href="#18-2-5-6-Final-Algebra-Expression" class="headerlink" title="18.2.5.6 Final Algebra Expression"></a>18.2.5.6 Final Algebra Expression</h5><p>总体抽象查询为M。</p><h3 id="18-3基本图形模式"><a href="#18-3基本图形模式" class="headerlink" title="18.3基本图形模式"></a>18.3基本图形模式</h3><p>当匹配图形模式时，可能的解决方案形成一个<em>多集</em> [multiset ]，也称为<em>bag</em>。多集是元素的无序集合，其中每个元素可能出现多次。它由一组元素和基数函数描述，该基数函数给出了多集中该集合中每个元素的出现次数。</p><p>解决方案映射写作μ。</p><p>dom(μ0)是一个空集，映射为μ0。</p><p>由确切的空映射μ0组成的多集Ω0，基数为1。This is the join identity.</p><p>映射RDF term到<code>t : &#123; (x, t) &#125;</code>的解决方案为μ(x)。</p><p>由 μ(?x-&gt;t)组成的多集Ω(x)，{ { (x, t) } } 基数为1。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">兼容映射</span><br><span class="line">对属于dom(μ1)和dom(μ2)的每个v，两个解决方案映射μ1和μ2是兼容的，有μ1(v) = μ2(v).</span><br></pre></td></tr></table></figure><p>这里, μ1(v) = μ2(v)意味着μ1(v)和μ2(v)是相同的RDF term.</p><p>如果μ1和μ2是兼容的，则μ1∪μ2也是一个映射。μ1 ∪ μ2写作merge(μ1, μ2)</p><p>在一个映射的多集Ω中，解决方案μ的基数为card[Ω](μ)。</p><h4 id="18-3-1-SPARQL-基本图模式匹配"><a href="#18-3-1-SPARQL-基本图模式匹配" class="headerlink" title="18.3.1 SPARQL 基本图模式匹配"></a>18.3.1 SPARQL 基本图模式匹配</h4><p>对于该部分查询，基本图形模式与活动图形相匹配。基本图形模式可以通过用术语替换变量和空白节点来实例化，给出实例的两个概念。使用从空白节点到RDF术语的RDF实例映射，σ替换空白节点；通过从查询变量到RDF术语的解决方案映射，变量将被替换。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">模式实例映射</span><br><span class="line">一个模式实例映射，P，是一个RDF实例映射，σ，和解决方案映射μ的组合。P(x) = μ(σ(x))</span><br></pre></td></tr></table></figure><p>对于BGP ‘x’，P（x）表示替换x中的空白节点b的结果，其中定义σ（b），x中的所有变量v定义为μ（v）。</p><p>任何模式实例映射都定义了唯一的解决方案映射，并通过将其分别限制为查询变量和空白节点，而获得的唯一的RDF实例映射。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">基本图模式匹配</span><br><span class="line">BGP是一个基本图模式并且G是一个RDF图.</span><br><span class="line"></span><br><span class="line">当存在模式实例映射P，μ是G的BGP解决方案，使得P(BGP)是G的一个子图，μ是P对BGP中查询变量的限制</span><br><span class="line"></span><br><span class="line">card[Ω](μ) = card[Ω](不同的RDF实例映射数量, σ, 使得P = μ(σ)是一个模式实例映射并且P(BGP)是G的一个子图).</span><br></pre></td></tr></table></figure><p>如果一个基本图形模式是空集，则该解决方案是Ω 0。</p><h4 id="18-3-2-空白节点的处理"><a href="#18-3-2-空白节点的处理" class="headerlink" title="18.3.2 空白节点的处理"></a>18.3.2 空白节点的处理</h4><p>此定义允许解决方案映射将基本图形模式BGP中的变量绑定到G中的空白节点。由于SPARQL处理结果格式文档中的空白节点标识符（SPARQL查询结果XML格式， SPARQL 1.1查询结果JSON格式和 SPARQL 1.1查询结果CSV和TSV格式）仅限于文档范围，因此不能理解为标识数据集活动图中的节点。如果DS是查询的数据集，则模式解决方案因此应理解为不是来自DS本身的活动图，而是来自称为<em>作用域图</em>的RDF<em>图，</em>它与DS的活动图等效，但是与DS或BGP不共享空白节点。同一范围图用于单个查询的所有解决方案。范围图纯粹是一种理论构造；实际上，仅通过空白节点标识符的文档作用域约定即可获得效果。</p><p>由于RDF空白节点可以为许多模式提供无限多个冗余解决方案，因此可以有无限多个模式解决方案（通过用不同的空白节点替换空白节点来获得）。因此，有必要以某种方式界定基本图形模式的解决方案。SPARQL使用子图匹配标准来确定基本图模式的解决方案。对于从基本图形模式到活动图形的子集的每个不同的模式实例映射，都有一个解决方案。</p><p>为简化计算而不是消除冗余进行了优化。即使数据集的活动图是lean，它也允许查询结果包含冗余 ，并且它允许逻辑等效的数据集产生不同的查询结果。</p><h3 id="18-4-属性路径模式"><a href="#18-4-属性路径模式" class="headerlink" title="18.4 属性路径模式"></a>18.4 属性路径模式</h3><p>本节定义属性路径模式的评估 。属性路径模式是主语端点（RDF术语或变量），属性路径表达和宾语端点。属性路径表达式的转换某些形式到其他SPARQL表达式，将长度为1的属性路径转换为三元组模式，而这又被组合成基本图模式。这样就留下了属性路径运算符ZeroOrOnePath，ZeroOrMorePath，OneOrMorePath和NegatedPropertySets，以及这些运算符中包含的路径表达式。</p><p>所有其余的属性路径表达式都以端点X和Y的形式<code>Path(X, path, Y)</code>存在于代数中 。例如：语法<code>(:p/:q)*</code>是ZeroOrMorePath表达式，其中涉及成为代数表达式<code>ZeroOrMorePath(seq(link(:p), link(:q)))</code>的序列属性路径。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">eval(Path(X, PP, Y))</span><br><span class="line">用于评估属性路径模式。这产生了解决方案μ映射的多集，每个解决方案映射都具有所使用变量的绑定（X和Y可以是变量）。一些操作符仅生成一组解决方案映射。</span><br><span class="line"></span><br><span class="line">对于在x1, x2, ..., xn中的变量</span><br><span class="line">Var(x1, x2, ..., xn) = &#123; xi | i in 1...n and xi is a variable &#125;</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th><code>x:term</code></th><th>when <code>x</code> is an RDF term</th></tr></thead><tbody><tr><td><code>x:var</code></td><td>when <code>x</code> is a variable</td></tr><tr><td><code>x:path</code></td><td>when <code>x</code> is a path expression</td></tr></tbody></table></div><p>通过在整个查询评估中匹配活动图来执行所有评估。为了清楚起见，我们在每个定义中都明确省略了活动图形。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">谓语属性路径评估</span><br><span class="line">使用一些IRI iri，Path(X, link(iri), Y)作为谓语逆属性路径</span><br><span class="line">eval(Path(X, link(iri), Y)) = evaluation of basic graph pattern &#123;X iri Y&#125;</span><br></pre></td></tr></table></figure><p>如果X和Y都是变量，等同于：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">eval(Path(X:var, link(iri), Y:var)) = </span><br><span class="line">    &#123; (X, xn) (Y, yn) | xn and yn are RDF terms and triple (xn iri yn) is in the active graph &#125;</span><br></pre></td></tr></table></figure><p>如果X是变量，Y是一个RDF term：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">eval(Path(X:var, link(iri), Y:term)) = </span><br><span class="line">    &#123; (X, xn) | xn is an RDF term and triple (xn iri Y) is in the active graph &#125;</span><br></pre></td></tr></table></figure><p>如果X是一个RDF term，Y是一个变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">eval(Path(X:term, link(iri), Y:var)) =</span><br><span class="line">    &#123; (Y, yn) | yn is an RDF term and triple (X iri yn) is in the active graph &#125;</span><br></pre></td></tr></table></figure><p>如果X和Y都是RDF terms:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">eval(Path(X:term, link(iri), Y:term)) = </span><br><span class="line">    &#123; μ0 &#125; if triple (X iri Y) is in the active graph</span><br><span class="line">    = &#123; &#123; &#125; &#125;</span><br><span class="line">    = Ω0</span><br><span class="line"></span><br><span class="line">eval(Path(X:term, link(iri), Y:term)) = </span><br><span class="line">    &#123; &#125; if triple (X iri Y) is not in the active graph</span><br></pre></td></tr></table></figure><p>非正式地，评估谓词属性路径与在查询评估中此时执行子查询相同 。 <code>SELECT * &#123; X P Y &#125;</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">评估逆属性路径</span><br><span class="line">P是一条属性路径，则：</span><br><span class="line">eval(Path(X, inv(P), Y)) = eval(Path(Y, P, X))</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">评估序列属性路径</span><br><span class="line">P和Q是属性路径表达式。V是一个新变量：</span><br><span class="line">A = Join( eval(Path(X, P, V)), eval(Path(V, Q, Y)) )</span><br><span class="line">eval(Path(X, seq(P,Q), Y)) = Project(A, Var(X,Y))</span><br></pre></td></tr></table></figure><p>等同于：SELECT * { X P _:a . _:a Q Y }</p><p>使用空白节点的<code>_:a</code>行为类似于变量（在简单情况下），但不会出现在<code>SELECT *</code>的结果中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">评估可选属性路径</span><br><span class="line">P和Q是属性路径表达式。</span><br><span class="line">eval(Path(X, alt(P,Q), Y)) = Union(eval(Path(X, P, Y)), eval(Path(X, Q, Y)))</span><br></pre></td></tr></table></figure><p>等同于：SELECT * { { X P Y } UNION { X Q Y } }</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">图的节点集</span><br><span class="line">图G的节点集，nodes(G)：</span><br><span class="line">nodes(G) = &#123; n | n是一个RDF Term，用于三元组G的主语和宾语&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">评估零或一路径</span><br><span class="line">eval(Path(X:term, ZeroOrOnePath(P), Y:var)) = &#123; (Y, yn) | yn = X or &#123;(Y, yn)&#125; in eval(Path(X,P,Y)) &#125;</span><br><span class="line">eval(Path(X:var, ZeroOrOnePath(P), Y:term)) = &#123; (X, xn) | xn = Y or &#123;(X, xn)&#125; in eval(Path(X,P,Y)) &#125;</span><br><span class="line">eval(Path(X:term, ZeroOrOnePath(P), Y:term)) = </span><br><span class="line">    &#123; &#123;&#125; &#125; if X = Y or eval(Path(X,P,Y)) is not empty</span><br><span class="line">    &#123; &#125; othewise</span><br><span class="line">eval(Path(X:var, ZeroOrOnePath(P), Y:var)) = </span><br><span class="line">    &#123; (X, xn) (Y, yn) | either (yn in nodes(G) and xn = yn) or &#123;(X,xn), (Y,yn)&#125; in eval(Path(X,P,Y)) &#125;</span><br></pre></td></tr></table></figure><p>我们定义了一个辅助函数ALP，该函数用于ZeroOrMorePath和OneOrMorePath的定义中。请注意，此处给出的算法用于指定功能。一个实现可以自由地通过任何为整个查询产生相同结果的方法来实现评估。ZeroOrMorePath和OneOrMorePath表单根据路径连接的不同节点返回匹配项。</p><p>匹配算法基于所有路径，并检测何时在该路径上访问了图形节点（主语或宾语）。</p><p>非正式地，此算法尝试通过在每个步骤中应用<code>路径</code>来扩展结果的多集 ，并指出它已针对该特定路径访问了哪些节点。如果针对所考虑的路径已访问了某个节点，则该节点不适合进行其他步骤。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ALP函数</span><br><span class="line">Let eval(x:term, path) be the evaluation of &#x27;path&#x27;, starting at RDF term x, </span><br><span class="line">                       and returning a multiset of RDF terms reached </span><br><span class="line">                       by repeated matches of path.</span><br><span class="line"></span><br><span class="line">ALP(x:term, path) = </span><br><span class="line">    Let V = empty multiset</span><br><span class="line">    ALP(x:term, path, V)</span><br><span class="line">    return is V</span><br><span class="line"></span><br><span class="line"># V is the set of nodes visited</span><br><span class="line"></span><br><span class="line">ALP(x:term, path, V:set of RDF terms) =</span><br><span class="line">    if ( x in V ) return </span><br><span class="line">    add x to V</span><br><span class="line">    X = eval(x,path) </span><br><span class="line">    For n:term in X</span><br><span class="line">        ALP(n, path, V)</span><br><span class="line">        End</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">评估零或多路径</span><br><span class="line">eval(Path(X:term, ZeroOrMorePath(path), vy:var)) =</span><br><span class="line">    &#123; &#123; (vy, n) &#125; | n in ALP(X, path) &#125;</span><br><span class="line"></span><br><span class="line">eval(Path(vx:var, ZeroOrMorePath(path), vy:var)) =</span><br><span class="line">    &#123; &#123; (vx, t), (vy, n) &#125; |  t in nodes(G), (vy, n) in eval(Path(t, ZeroOrMorePath(path), vy)) &#125;</span><br><span class="line"></span><br><span class="line">eval(Path(vx:var, ZeroOrMorePath(path), y:term)) = </span><br><span class="line">    eval(Path(y:term, ZeroOrMorePath(inv(path)), vx:var))</span><br><span class="line"></span><br><span class="line">eval(Path(x:term, ZeroOrMorePath(path), y:term)) = </span><br><span class="line">    &#123; &#123; &#125; &#125; if &#123; (vy:var,y) &#125; in eval(Path(x, ZeroOrMorePath(path) vy)</span><br><span class="line">    &#123; &#125; otherwise</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">评估一或多路径</span><br><span class="line">eval(Path(X, OneOrMorePath(path), Y))</span><br><span class="line"></span><br><span class="line"># For OneOrMorePath, we take one step of the path then start</span><br><span class="line"># recording nodes for results.</span><br><span class="line"></span><br><span class="line">eval(Path(x:term, OneOrMorePath(path), vy:var)) =</span><br><span class="line">    Let X = eval(x, path)</span><br><span class="line">    Let V = the empty multiset</span><br><span class="line">    For n in X</span><br><span class="line">        ALP(n, path, V)</span><br><span class="line">        End</span><br><span class="line">    result is V</span><br><span class="line"></span><br><span class="line">eval(Path(vx:var, OneOrMorePath(path), vy:var)) =</span><br><span class="line">   &#123; &#123; (vx, t), (vy, n) &#125; |  t in nodes(G), (vy, n) in eval(Path(t, OneOrMorePath(path), vy)) &#125;</span><br><span class="line"></span><br><span class="line">eval(Path(vx:var, OneOrMorePath(path), y:term)) =</span><br><span class="line">   eval(Path(y:term, OneOrMorePath(inv(path)), vx))</span><br><span class="line"></span><br><span class="line">eval(Path(x:term, OneOrMorePath(path), y:term)) =</span><br><span class="line">    &#123; &#123; &#125; &#125; if &#123; (vy:var, y) &#125; in eval(Path(x, OneOrMorePath(path), vy))</span><br><span class="line">    &#123; &#125; otherwise</span><br><span class="line">	</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">评估否定属性集</span><br><span class="line">Write μ&#x27; as the extension of a solution mapping:</span><br><span class="line">μ&#x27;(μ,x) = μ(x)   if x is a variable</span><br><span class="line">μ&#x27;(μ,t) = t   if t is a RDF term</span><br><span class="line">	</span><br><span class="line">Let x and y be variables or RDF terms, and S a set of IRIs:</span><br><span class="line"></span><br><span class="line">eval(Path(x, NPS(S), y)) = &#123; μ | ∃ triple(μ&#x27;(μ,x), p, μ&#x27;(μ,y)) in G, such that the IRI of p ∉ S &#125;</span><br></pre></td></tr></table></figure><h3 id="18-5-SPARQL代数式"><a href="#18-5-SPARQL代数式" class="headerlink" title="18.5 SPARQL代数式"></a>18.5 SPARQL代数式</h3><p>对于SPARQL抽象查询中的每个剩余符号，我们定义一个用于求值的运算符。相同名称的SPARQL代数运算符用于评估SPARQL抽象查询节点，如“评估语义”一节中所述。上面已经描述了基本图形模式和属性路径模式的评估。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Filter</span><br><span class="line">Let Ω be a multiset of solution mappings and expr be an expression. We define:</span><br><span class="line"></span><br><span class="line">Filter(expr, Ω, D(G)) = &#123; μ | μ in Ω and expr(μ) is an expression that has an effective boolean value of true &#125;</span><br><span class="line"></span><br><span class="line">card[Filter(expr, Ω, D(G))](μ) = card[Ω](μ)</span><br><span class="line"></span><br><span class="line">Note that evaluating an exists(pattern) expression uses the dataset and active graph, D(G). See the evaluation of filter.</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Join</span><br><span class="line">Let Ω1 and Ω2 be multisets of solution mappings. We define:</span><br><span class="line"></span><br><span class="line">Join(Ω1, Ω2) = &#123; merge(μ1, μ2) | μ1 in Ω1and μ2 in Ω2, and μ1 and μ2 are compatible &#125;</span><br><span class="line"></span><br><span class="line">card[Join(Ω1, Ω2)](μ) =</span><br><span class="line">    for each merge(μ1, μ2), μ1 in Ω1and μ2 in Ω2 such that μ = merge(μ1, μ2),</span><br><span class="line">        sum over (μ1, μ2), card[Ω1](μ1)*card[Ω2](μ2)</span><br></pre></td></tr></table></figure><p>Join中的解决方案映射μ可能出现在不同的解决方案映射中，多个集合中的μ1和μ2被连接。 μ的基数是所有可能性的基数之和。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Diff</span><br><span class="line">Let Ω1 and Ω2 be multisets of solution mappings and expr be an expression. We define:</span><br><span class="line"></span><br><span class="line">Diff(Ω1, Ω2, expr) = &#123; μ | μ in Ω1 such that ∀ μ′ in Ω2, either μ and μ′ are not compatible or μ and μ&#x27; are compatible and expr(merge(μ, μ&#x27;)) has an effective boolean value of false &#125;</span><br><span class="line"></span><br><span class="line">card[Diff(Ω1, Ω2, expr)](μ) = card[Ω1](μ)</span><br></pre></td></tr></table></figure><p>Diff在内部用于LeftJoin的定义。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">LeftJoin</span><br><span class="line"></span><br><span class="line">Let Ω1 and Ω2 be multisets of solution mappings and expr be an expression. We define:</span><br><span class="line"></span><br><span class="line">LeftJoin(Ω1, Ω2, expr) = Filter(expr, Join(Ω1, Ω2)) ∪ Diff(Ω1, Ω2, expr)</span><br><span class="line"></span><br><span class="line">card[LeftJoin(Ω1, Ω2, expr)](μ) = card[Filter(expr, Join(Ω1, Ω2))](μ) + card[Diff(Ω1, Ω2, expr)](μ)</span><br><span class="line"></span><br><span class="line">展开写作：</span><br><span class="line">LeftJoin(Ω1, Ω2, expr) =</span><br><span class="line">    &#123; merge(μ1, μ2) | μ1 in Ω1 and μ2 in Ω2, μ1 and μ2 are compatible and expr(merge(μ1, μ2)) is true &#125;</span><br><span class="line">∪</span><br><span class="line">    &#123; μ1 | μ1 in Ω1, ∀ μ2 in Ω2, μ1 and μ2 are not compatible, or Ω2 is empty &#125;</span><br><span class="line">∪</span><br><span class="line">    &#123; μ1 | μ1 in Ω1, ∃ μ2 in Ω2, μ1 and μ2 are compatible and expr(merge(μ1, μ2)) is false. &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>由于这些是<u>不同</u>的，因此LeftJoin的基数就是定义的这些各个组成部分的基数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Union</span><br><span class="line"></span><br><span class="line">Let Ω1 and Ω2 be multisets of solution mappings. We define:</span><br><span class="line"></span><br><span class="line">Union(Ω1, Ω2) = &#123; μ | μ in Ω1 or μ in Ω2 &#125;</span><br><span class="line"></span><br><span class="line">card[Union(Ω1, Ω2)](μ) = card[Ω1](μ) + card[Ω2](μ)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Minus</span><br><span class="line"></span><br><span class="line">Let Ω1 and Ω2 be multisets of solution mappings. We define:</span><br><span class="line"></span><br><span class="line">Minus(Ω1, Ω2) = &#123; μ | μ in Ω1 . ∀ μ&#x27; in Ω2, either μ and μ&#x27; are not compatible or dom(μ) and dom(μ&#x27;) are disjoint &#125;</span><br><span class="line"></span><br><span class="line">card[Minus(Ω1, Ω2)](μ) = card[Ω1](μ)</span><br></pre></td></tr></table></figure><p>添加了对dom(μ)和dom(μ’)的附加限制，因为如果Ω2中的解决方案映射没有与Ω1的解决方案映射相同的变量，那么Minus（Ω1，Ω2）将为空，不论Ω2的其余部分如何。空解决方案映射与所有其他解决方案映射兼容，因此对于任何模式P，P MINUS {}都将为空。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Extend</span><br><span class="line">Let μ be a solution mapping, Ω a multiset of solution mappings, var a variable and expr be an expression, then we define:</span><br><span class="line"></span><br><span class="line">Extend(μ, var, expr) = μ ∪ &#123; (var,value) | var not in dom(μ) and value = expr(μ) &#125;</span><br><span class="line"></span><br><span class="line">Extend(μ, var, expr) = μ if var not in dom(μ) and expr(μ) is an error</span><br><span class="line"></span><br><span class="line">Extend is undefined when var in dom(μ).</span><br><span class="line"></span><br><span class="line">Extend(Ω, var, expr) = &#123; Extend(μ, var, expr) | μ in Ω &#125;</span><br></pre></td></tr></table></figure><p>[ x | C ] ，对于一个元素序列，C为x上的条件。</p><p>card[L](x)为x在L中的基数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ToList</span><br><span class="line">Let Ω be a multiset of solution mappings. We define:</span><br><span class="line"></span><br><span class="line">ToList(Ω) = a sequence of mappings μ in Ω in any order, with card[Ω](μ) occurrences of μ</span><br><span class="line"></span><br><span class="line">card[ToList(Ω)](μ) = card[Ω](μ)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">OrderBy</span><br><span class="line">Let Ψ be a sequence of solution mappings. We define:</span><br><span class="line"></span><br><span class="line">OrderBy(Ψ, condition) = [ μ | μ in Ψ and the sequence satisfies the ordering condition]</span><br><span class="line"></span><br><span class="line">card[OrderBy(Ψ, condition)](μ) = card[Ψ](μ)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Project</span><br><span class="line">Let Ψ be a sequence of solution mappings and PV a set of variables.</span><br><span class="line"></span><br><span class="line">For mapping μ, write Proj(μ, PV) to be the restriction of μ to variables in PV.</span><br><span class="line"></span><br><span class="line">Project(Ψ, PV) = [ Proj(Ψ[μ], PV) | μ in Ψ ]</span><br><span class="line"></span><br><span class="line">card[Project(Ψ, PV)](μ) = card[Ψ](μ)</span><br><span class="line"></span><br><span class="line">The order of Project(Ψ, PV) must preserve any ordering given by OrderBy.</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Distinct</span><br><span class="line">Let Ψ be a sequence of solution mappings. We define:</span><br><span class="line"></span><br><span class="line">Distinct(Ψ) = [ μ | μ in Ψ ]</span><br><span class="line"></span><br><span class="line">card[Distinct(Ψ)](μ) = 1</span><br><span class="line"></span><br><span class="line">The order of Distinct(Ψ) must preserve any ordering given by OrderBy.</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Reduced</span><br><span class="line">Let Ψ be a sequence of solution mappings. We define:</span><br><span class="line"></span><br><span class="line">Reduced(Ψ) = [ μ | μ in Ψ ]</span><br><span class="line"></span><br><span class="line">card[Reduced(Ψ)](μ) is between 1 and card[Ψ](μ)</span><br><span class="line"></span><br><span class="line">The order of Reduced(Ψ) must preserve any ordering given by OrderBy.</span><br></pre></td></tr></table></figure><p>Reduced解序列修改器不保证定义的基数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Slice</span><br><span class="line">Let Ψ be a sequence of solution mappings. We define:</span><br><span class="line"></span><br><span class="line">Slice(Ψ, start, length)[i] = Ψ[start+i] for i = 0 to (length-1)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ToMultiSet</span><br><span class="line">Let Ψ be a solution sequence. We define:</span><br><span class="line"></span><br><span class="line">ToMultiSet(Ψ) = &#123; μ | μ in Ψ &#125;</span><br><span class="line"></span><br><span class="line">card[ToMultiSet(Ψ)](μ) = card[Ψ](μ)</span><br></pre></td></tr></table></figure><p>ListEval是一个函数，用于根据解决方案评估表达式列表并返回结果值列表。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ToMultiset</span><br><span class="line"></span><br><span class="line">ToMultiset将序列转换为具有与该序列相同的元素和基数的多集。序列的顺序对所得的多集没有影响，并且重复项被保留。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Exists</span><br><span class="line"></span><br><span class="line">exists(pattern)是一个函数，如果在评估时给出当前解映射和活动图，则如果模式评估为非空解序列，则返回true；否则返回false。</span><br></pre></td></tr></table></figure><h4 id="18-5-1-聚合代数式"><a href="#18-5-1-聚合代数式" class="headerlink" title="18.5.1 聚合代数式"></a>18.5.1 聚合代数式</h4><p>Group是根据解决方案的某些属性将解决方案序列分为多个解决方案的函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Group</span><br><span class="line"></span><br><span class="line">Group 根据解决方案序列评估表达式列表，产生一组从键到解决方案序列的部分函数。</span><br><span class="line"></span><br><span class="line">Group(exprlist, Ω) = &#123; ListEval(exprlist, μ) → &#123; μ&#x27; | μ&#x27; in Ω, ListEval(exprlist, μ) = ListEval(exprlist, μ&#x27;) &#125; | μ in Ω &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ListEval</span><br><span class="line"></span><br><span class="line">ListEval((expr1, ..., exprn), μ) returns a list (e1, ..., en), where ei = expri(μ) or error.</span><br><span class="line"></span><br><span class="line">ListEval 保留由于评估列表元素而导致的错误。</span><br></pre></td></tr></table></figure><p>请注意，尽管ListEval的结果可能是错误，并且可以使用错误进行分组，但是在投影时会删除包含错误值的解决方案。</p><p>ListEval((unbound), μ) = (error)，因为对未绑定表达式的求值是错误的。</p><p>Aggregation，一个计算标量值作为聚合表达式输出的函数。在SELECT子句，HAVING评估过程和ORDER BY（需要时）中使用它。聚合使用集合函数计算解决方案组上的聚合值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Aggregation</span><br><span class="line"></span><br><span class="line">Let exprlist be a list of expressions or *, func a set function, scalarvals a set of partial functions (possibly empty) passed from the aggregate in the query, and let &#123; key1→Ω1, ..., keym→Ωm &#125; be a multiset of partial functions from keys to solution sequences as produced by the grouping step.</span><br><span class="line"></span><br><span class="line">Aggregation 将集合函数func应用于给定的多集，并为每个键和该键的解决方案分区生成一个值。</span><br><span class="line"></span><br><span class="line">Aggregation(exprlist, func, scalarvals, &#123; key1→Ω1, ..., keym→Ωm &#125; )</span><br><span class="line">   = &#123; (key, F(Ω)) | key → Ω in &#123; key1→Ω1, ..., keym→Ωm &#125; &#125;</span><br><span class="line"></span><br><span class="line">where</span><br><span class="line">  M(Ω) = &#123; ListEval(exprlist, μ) | μ in Ω &#125;</span><br><span class="line">  F(Ω) = func(M(Ω), scalarvals), for non-DISTINCT</span><br><span class="line">  F(Ω) = func(Distinct(M(Ω)), scalarvals), for DISTINCT</span><br><span class="line">特殊情况：将COUNT与表达式*一起使用时，如果存在DISTINCT关键字，则F的值将是组解序列，card [Ω]或card [Distinct(Ω)]的基数。</span><br></pre></td></tr></table></figure><p><em>标</em>量用于绕开分组机制将值传递给基础set函数。例如，聚合表达式<code>GROUP_CONCAT(?x ; separator=&quot;|&quot;)</code>的标量参数为{ “separator” → “|” }。</p><p>所有聚合都可以在其参数列表中将关键字<code>DISTINCT</code> 作为第一个标记。如果存在此关键字，则func的第一个参数是Distinct（M）。</p><p><strong>示例</strong>给出一个带有下列值的解决方案多集(Ω) ：</p><div class="table-container"><table><thead><tr><th>solution</th><th>?x</th><th>?y</th><th>?z</th></tr></thead><tbody><tr><td>μ1</td><td>1</td><td>2</td><td>3</td></tr><tr><td>μ2</td><td>1</td><td>3</td><td>4</td></tr><tr><td>μ3</td><td>2</td><td>5</td><td>6</td></tr></tbody></table></div><p>查询表达式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT (ex:agg(?y, ?z) AS ?agg) </span><br><span class="line">WHERE &#123; ?x ?y ?z </span><br><span class="line">&#125; GROUP BY ?x.</span><br></pre></td></tr></table></figure><p>G = Group((?x), Ω) = { ( (1), { μ1, μ2 } ), ( (2), { μ3 } ) }</p><p>所以Aggregation((?y, ?z), ex:agg, {}, G) = { ((1), eg:agg({(2, 3), (3, 4)}, {})), ((2), eg:agg({(5, 6)}, {})) }.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">AggregateJoin</span><br><span class="line"></span><br><span class="line">Let S1, ..., Sn be a list of sets, where each set Si contains key to (aggregated) value maps as produced by Aggregate.</span><br><span class="line"></span><br><span class="line">Let K = &#123; key | key in dom(Sj) for some 1 &lt;= j &lt;= n &#125; be the set of keys, then</span><br><span class="line">AggregateJoin(S1, ..., Sn) = &#123; agg1→val1, ..., aggn→valn | key in K and key→vali in Si for each 1 &lt;= i &lt;= n &#125;</span><br></pre></td></tr></table></figure><p>Flatten是用于将列表的多集合折叠为多集合的功能，因此，例如{((1，2), (3，4)}}变为{1, 2, 3, 4}。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Flatten</span><br><span class="line"></span><br><span class="line">The Flatten(M) function takes a multiset of lists, M &#123;(L1, L2, ...), ...&#125;, and returns the multiset &#123; x | L in M and x in L &#125;.</span><br></pre></td></tr></table></figure><h5 id="18-5-1-1-Set-Functions"><a href="#18-5-1-1-Set-Functions" class="headerlink" title="18.5.1.1 Set Functions"></a>18.5.1.1 Set Functions</h5><p>作为SPARQL聚合基础的集合函数都具有一个公共签名：SetFunc(M)或SetFunc(M，scalarvals)，其中M是列表的多集，而scalarvals是一个或多个标量值，这些值通过间接传递给set函数。 SPARQL语法中聚合的(…; key = value)语法。SPARQL Query 1.1中的内置聚合支持的唯一用法是<code>GROUP_CONCAT</code>，如中所述<code>GROUP_CONCAT(?x ; separator=&quot;, &quot;)</code>。</p><p>请注意，名称“ Set Function”在某种程度上是历史性的-设置函数的参数实际上是多集。由于与SQL Set函数具有通用性，因此保留了该名称，SQL Set Function也可以在多集合上运行。</p><p>本文档中定义的一组功能是计数，和，最小值，最大值，平均值，GroupConcat和样品-对应于所述聚集体<code>COUNT</code>，<code>SUM</code>，<code>MIN</code>，<code>MAX</code>，<code>AVG</code>，<code>GROUP_CONCAT</code>，和<code>SAMPLE</code>。在以下各节中可以找到定义。系统可能会选择使用本地扩展来扩展此集合，并使用与函数和强制类型转换相同的符号。注意，除非使用分隔符; 时，这要求解析器在确定使用聚合的查询中是否存在任何错误之前，必须先了解某个IRI是否引用了函数，强制转换或聚合。</p><h5 id="18-5-1-2-Count"><a href="#18-5-1-2-Count" class="headerlink" title="18.5.1.2 Count"></a>18.5.1.2 Count</h5><p>Count是一个SPARQL内置函数，用于对给定表达式在聚合组中具有绑定值和非错误值的次数进行计数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Count</span><br><span class="line"></span><br><span class="line">xsd:integer Count(multiset M)</span><br><span class="line">N = Flatten(M)</span><br><span class="line"></span><br><span class="line">remove error elements from N</span><br><span class="line"></span><br><span class="line">Count(M) = card[N]</span><br></pre></td></tr></table></figure><h5 id="18-5-1-3-Sum"><a href="#18-5-1-3-Sum" class="headerlink" title="18.5.1.3 Sum"></a>18.5.1.3 Sum</h5><p>Sum是一个SPARQL内置函数，它将返回通过对聚合组中的值求和而获得的数值。类型提升按照op：numeric-add函数的方式进行，可传递地应用（请参见下面的定义），因此SUM(?x)的值在一个聚合组中，其中?x的值为1（整数），2.0e0（浮点） ，而3.0（十进制）将为6.0（浮点数）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Sum</span><br><span class="line"></span><br><span class="line">numeric Sum(multiset M)</span><br><span class="line">The Sum set function is used by the SUM aggregate in the syntax.</span><br><span class="line"></span><br><span class="line">Sum(M) = Sum(ToList(Flatten(M))).</span><br><span class="line"></span><br><span class="line">Sum(S) = op:numeric-add(S1, Sum(S2..n)) when card[S] &gt; 1</span><br><span class="line">Sum(S) = op:numeric-add(S1, 0) when card[S] = 1</span><br><span class="line">Sum(S) = &quot;0&quot;^^xsd:integer when card[S] = 0</span><br><span class="line"></span><br><span class="line">In this way, Sum(&#123;1, 2, 3&#125;) = op:numeric-add(1, op:numeric-add(2, op:numeric-add(3, 0))).</span><br></pre></td></tr></table></figure><h5 id="18-5-1-4-Avg"><a href="#18-5-1-4-Avg" class="headerlink" title="18.5.1.4 Avg"></a>18.5.1.4 Avg</h5><p>Avg内置函数可计算整个组中某个表达式的平均值。它是根据总和和计数来定义的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Avg</span><br><span class="line"></span><br><span class="line">numeric Avg(multiset M)</span><br><span class="line">Avg(M) = &quot;0&quot;^^xsd:integer, where Count(M) = 0</span><br><span class="line"></span><br><span class="line">Avg(M) = Sum(M) / Count(M), where Count(M) &gt; 0</span><br></pre></td></tr></table></figure><p>Avg({1, 2, 3}) = Sum({1, 2, 3})/Count({1, 2, 3}) = 6/3 = 2.</p><h5 id="18-5-1-5-Min"><a href="#18-5-1-5-Min" class="headerlink" title="18.5.1.5 Min"></a>18.5.1.5 Min</h5><p>Min是一个SPARQL内置函数，分别从组中返回最小值。</p><p>它利用SPARQL ORDER BY排序定义，以允许对任意类型的表达式进行排序。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Min</span><br><span class="line"></span><br><span class="line">term Min(multiset M)</span><br><span class="line">Min(M) = Min(ToList(Flatten(M)))</span><br><span class="line"></span><br><span class="line">Min(&#123;&#125;) = error.</span><br><span class="line"></span><br><span class="line">The flattened multiset of values passed as an argument is converted to a sequence S, this sequence is ordered as per the ORDER BY ASC clause.</span><br><span class="line"></span><br><span class="line">Min(S) = S0</span><br></pre></td></tr></table></figure><h5 id="18-5-1-6-Max"><a href="#18-5-1-6-Max" class="headerlink" title="18.5.1.6 Max"></a>18.5.1.6 Max</h5><p>Max是一个SPARQL内置函数，分别从组中返回最大值。</p><p>它利用SPARQL ORDER BY排序定义，以允许对任意类型的表达式进行排序。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Max</span><br><span class="line"></span><br><span class="line">term Max(multiset M)</span><br><span class="line">Max(M) = Max(ToList(Flatten(M)))</span><br><span class="line"></span><br><span class="line">Max(&#123;&#125;) = error.</span><br><span class="line"></span><br><span class="line">The multiset of values passed as an argument is converted to a sequence S, this sequence is ordered as per the ORDER BY DESC clause.</span><br><span class="line"></span><br><span class="line">Max(S) = S0</span><br></pre></td></tr></table></figure><h5 id="18-5-1-7-GroupConcat"><a href="#18-5-1-7-GroupConcat" class="headerlink" title="18.5.1.7 GroupConcat"></a>18.5.1.7 GroupConcat</h5><p>GroupConcat是一个内置函数，该函数对具有组的表达式的值执行字符串连接。不指定字符串的顺序。串联中使用的分隔符可以使用标量参数SEPARATOR给出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">GroupConcat</span><br><span class="line"></span><br><span class="line">literal GroupConcat(multiset M)</span><br><span class="line">If the &quot;separator&quot; scalar argument is absent from GROUP_CONCAT then it is taken to be the &quot;space&quot; character, unicode codepoint U+0020.</span><br><span class="line"></span><br><span class="line">The multiset of values, M passed as an argument is converted to a sequence S.</span><br><span class="line"></span><br><span class="line">GroupConcat(M, scalarvals) = GroupConcat(Flatten(M), scalarvals(&quot;separator&quot;))</span><br><span class="line"></span><br><span class="line">GroupConcat(S, sep) = &quot;&quot;, where |S| = 0</span><br><span class="line"></span><br><span class="line">GroupConcat(S, sep) = CONCAT(&quot;&quot;, S0), where |S| = 1</span><br><span class="line"></span><br><span class="line">GroupConcat(S, sep) = CONCAT(S0, sep, GroupConcat(S1..n-1, sep)), where |S| &gt; 1</span><br></pre></td></tr></table></figure><p>GroupConcat({“a”, “b”, “c”}, {“separator” → “.”}) = “a.b.c”.</p><h5 id="18-5-1-8-Sample"><a href="#18-5-1-8-Sample" class="headerlink" title="18.5.1.8 Sample"></a>18.5.1.8 Sample</h5><p>Sample是一个集合函数，它从传递给它的多重集中返回一个任意值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Sample</span><br><span class="line"></span><br><span class="line">RDFTerm Sample(multiset M)</span><br><span class="line">Sample(M) = v, where v in Flatten(M)</span><br><span class="line"></span><br><span class="line">Sample(&#123;&#125;) = error</span><br></pre></td></tr></table></figure><p>给出Sample({“a”, “b”, “c”}), “a”, “b”和 “c”都是有效返回值。请注意，对于给定的输入，不要求Sample()是确定性的，唯一的限制是输出值必须存在于输入多集中。</p><h3 id="18-6-评估语义"><a href="#18-6-评估语义" class="headerlink" title="18.6 评估语义"></a>18.6 评估语义</h3><p>eval(D(G), algebra expression)定义为对具有活动图G的数据集D的代数表达式的评估。活动图最初是默认图。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">D : a dataset</span><br><span class="line">D(G) : D a dataset with active graph G (the one patterns match against)</span><br><span class="line">D[i] : The graph with IRI i in dataset D</span><br><span class="line">P, P1, P2 : graph patterns</span><br><span class="line">L : a solution sequence</span><br><span class="line">F : an expression</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">基本图模式的评估</span><br><span class="line">eval(D(G), BGP) = multiset of solution mappings</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">属性路径模式的评估</span><br><span class="line">eval(D(G), Path(X, path, Y)) = multiset of solution mappings</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Filter的评估</span><br><span class="line">eval(D(G), Filter(F, P)) = Filter(F, eval(D(G),P), D(G))</span><br></pre></td></tr></table></figure><p>“替换”是一个过滤函数，用于支持对已转换为<code>exits</code>的EXISTS和NOT EXISTS表单进行评估。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Substitute</span><br><span class="line"></span><br><span class="line">Let μ be a solution mapping.</span><br><span class="line"></span><br><span class="line">substitute(pattern, μ) = the pattern formed by replacing every occurrence of a variable v in pattern by μ(v) for each v in dom(μ)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Exists评估</span><br><span class="line"></span><br><span class="line">Let μ be the current solution mapping for a filter and P a graph pattern:</span><br><span class="line"></span><br><span class="line">The value exists(P), given D(G) is true if and only if eval(D(G), substitute(P, μ)) is a non-empty sequence.</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Join评估</span><br><span class="line">eval(D(G), Join(P1, P2)) = Join(eval(D(G), P1), eval(D(G), P2))</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LeftJoin评估</span><br><span class="line">eval(D(G), LeftJoin(P1, P2, F)) = LeftJoin(eval(D(G), P1), eval(D(G), P2), F)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Union评估</span><br><span class="line">eval(D(G), Union(P1,P2)) = Union(eval(D(G), P1), eval(D(G), P2))</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Graph评估</span><br><span class="line">if IRI is a graph name in D</span><br><span class="line">eval(D(G), Graph(IRI,P)) = eval(D(D[IRI]), P)</span><br><span class="line">if IRI is not a graph name in D</span><br><span class="line">eval(D(G), Graph(IRI,P)) = the empty multiset</span><br><span class="line">eval(D(G), Graph(var,P)) =</span><br><span class="line">     Let R be the empty multiset</span><br><span class="line">     foreach IRI i in D</span><br><span class="line">        R := Union(R, Join( eval(D(D[i]), P) , Ω(?var-&gt;i) )</span><br><span class="line">     the result is R</span><br></pre></td></tr></table></figure><p>图的评估使用SPARQL代数联合运算符。解决方案映射的基数是每个联接操作中该解决方案映射的基数的总和。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Definition: Evaluation of Group</span><br><span class="line"></span><br><span class="line">eval(D(G), Group(exprlist, P)) = Group(exprlist, eval(D(G), P))</span><br><span class="line"></span><br><span class="line">Definition: Evaluation of Aggregation</span><br><span class="line"></span><br><span class="line">eval(D(G), Aggregation(exprlist, func, scalarvals, P)) = Aggregation(exprlist, func, scalarvals, eval(D(G), P))</span><br><span class="line"></span><br><span class="line">Definition: Evaluation of AggregateJoin</span><br><span class="line"></span><br><span class="line">eval(D(G), AggregateJoin(A1, ..., An)) = AggregateJoin(eval(D(G), A1), ..., eval(D(G), An))</span><br></pre></td></tr></table></figure><p>如果eval(D(G), Ai)是一个错误，则忽略</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Definition: Evaluation of Extend</span><br><span class="line">eval(D(G), Extend(P, var, expr)) = Extend(eval(D(G), P), var, expr)</span><br><span class="line"></span><br><span class="line">Definition: Evaluation of ToList</span><br><span class="line">eval(D(G), ToList(P)) = ToList(eval(D(G), P))</span><br><span class="line"></span><br><span class="line">Definition: Evaluation of Distinct</span><br><span class="line">eval(D(G), Distinct(L)) = Distinct(eval(D(G), L))</span><br><span class="line">          </span><br><span class="line">Definition: Evaluation of Reduced</span><br><span class="line">eval(D(G), Reduced(L)) = Reduced(eval(D(G), L))</span><br><span class="line">          </span><br><span class="line">Definition: Evaluation of Project</span><br><span class="line">eval(D(G), Project(L, vars)) = Project(eval(D(G), L), vars)</span><br><span class="line">          </span><br><span class="line">Definition: Evaluation of OrderBy</span><br><span class="line">eval(D(G), OrderBy(L, condition)) = OrderBy(eval(D(G), L), condition)</span><br><span class="line">          </span><br><span class="line">Definition: Evaluation of ToMultiSet</span><br><span class="line">eval(D(G), ToMultiSet(L)) = ToMultiSet(eval(D), M))</span><br><span class="line"></span><br><span class="line">Definition: Evaluation of Slice</span><br><span class="line">eval(D(G), Slice(L, start, length)) = Slice(eval(D(G), L), start, length)</span><br></pre></td></tr></table></figure><h3 id="18-7-扩展SPARQL基本图匹配"><a href="#18-7-扩展SPARQL基本图匹配" class="headerlink" title="18.7 扩展SPARQL基本图匹配"></a>18.7 扩展SPARQL基本图匹配</h3><p>通过重写基本图形模式的匹配条件，可以将整体SPARQL设计用于查询，该查询采用比简单蕴含更复杂的蕴含形式。由于以单一通用形式陈述这些条件是一个开放的研究问题，该条件适用于所有形式的蕴含，并以最佳方式消除了不必要或不适当的冗余，因此本文档仅给出了任何此类解决方案都应满足的必要条件。这些将需要扩展到每个特定案例的完整定义。</p><p>基本图形模式与三元组模式的关系相同，而RDF图形与RDF三元组模式的关系相同，并且许多相同的术语都可以应用于它们。特别地，如果在三元组模式的术语之间存在双映射M ，则两个基本图形模式被认为是<em>等效</em>的，三元组模式将空白节点映射到空白节点，并将变量，文字和IRI映射到它们自己，从而使三元组（s，p当且仅当三元组（M（s），M（p），M（o））在第二个模式中时，才在第一个模式中。该定义通过在等效模式之间保留变量名称，将RDF图形等效性扩展到基本图形模式。</p><p>一个蕴含规则指定</p><ol><li>RDF图的一个子集，被称为<strong>well-formed</strong>的规则</li><li><em>well-formed</em>图的子集与<em>well-formed</em>图的子集之间的<em>蕴含</em>关系。</li></ol><p>一些蕴含机制可以将某些RDF图分类为不一致。例如，RDF图：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_：x rdf：type xsd：string.</span><br><span class="line">_：x rdf：type xsd：decimal.</span><br></pre></td></tr></table></figure><p>当D包含XSD数据类型时，是D不一致的。本规范未涵盖查询对不一致图的影响，但必须由特定的SPARQL扩展名指定。</p><p>蕴含规则E必须提供基本图模式评估的条件，以便对于任何基本图模式BGP，任何RDF图G和任何满足条件的评估，唯一确定的解决方案多元集取决于RDF图的等效性。我们使用Eval-E（G，BGP）在E上评估G上的BGP的解决方案表示多集。<br>蕴含必须进一步满足以下条件：</p><ol><li><p>对任何E不一致的活动图AG，蕴含规则E唯一地指定了与AG等效的作用域图SG。</p></li><li><p>指定了一组E的<em>well-formed</em>的图，以便对于Eval-E（SG，BGP）中的任何基本图模式BGP，作用域图SG和解决方案映射μ，对于E的图μ（BGP）是<em>well-formed</em>。</p></li><li><p>对于任何基本图形图案BGP和范围界定图SG，如果μ 1，…，μ Ñ在EVAL-E（SG，BGP）和BGP 1，…，BGP Ñ是基本图形的图案的所有等效于BGP但不彼此或与SG共享任何空白节点，则</p><p>​ SG E-entails (SG union μ1(BGP1) union … union μn(BGPn))</p></li></ol><p>这些条件不能完全确定可能的答案，因为RDF允许无限数量的冗余。因此，此外，必须满足以下条件。</p><ol><li>蕴含规则应提供适当的条件，以防止琐碎的无限解决方案多集适用于该制度。</li></ol><h4 id="18-7-1-注意事项"><a href="#18-7-1-注意事项" class="headerlink" title="18.7.1 注意事项"></a>18.7.1 注意事项</h4><p>（a）SG通常在图形上与AG等效，但是将其限制为E-等效性允许在查询之前将某些形式的规范化（例如，消除语义冗余）应用于源文档。</p><p>（b）条件3中的构造确保解决方案映射引入的任何空白节点的使用方式与SG中空白节点的出现方式内部一致。这确保仅当如此标识的空白节点在SG中确实相同时，空白节点标识符才会出现在答案集中的多个答案中。如果扩展名不允许绑定到空白节点，则可以将此条件简化为以下条件：</p><p>​ SG E-entails μ(BGP) for each solution mapping μ.</p><p>（c）这些条件不强加SPARQL要求SG不与AG或BGP共享空白节点。特别是，它允许SG实际上是AG。这允许使用以下查询协议，其中空白节点标识符在查询和源文档之间或在多个查询之间保留其含义。但是，当前的SPARQL协议规范不支持此类协议。</p><p>（d）由于条件1至3仅是答案的必要条件，因此条件4允许以各种方式限制合法答案的情况。</p><p>（e）这些条件均未明确涉及BGP中空白节点上的实例映射。对于某些蕴含机制，单个实例映射的存在无法完全捕获空白节点的存在性解释。这些条件允许此类机制为查询模式中的空白节点提供“完全存在”的读数。</p><p>显而易见，对于SG为E的情况，SPARQL满足这些条件，因为SG上的SPARQL条件是它与AG在图上等效，但不与AG或BGP共享空白节点（满足第一个条件） ）。唯一不平凡的条件是（3）。对于每个解映射μi，根据基本图形模式匹配的定义，存在映射σi的RDF实例，使得PI(BgPi)是SG的子图，其中Pi是由μi和σi组成的模式实例映射。由于bgPi和SG没有共同的空白节点，所以σi和μi的范围不包含来自bgpi的空节点；因此，解映射μi和pi的σ实例映射rdf i通勤，因此PI(BgPi)=σi(μi(bgpi)。所以</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">P1(BGP1) union ... union Pn(BGPn)</span><br><span class="line">= σ1(μ1(BGP1)) union ... union σn(μn(BGPn))</span><br><span class="line">= [ σ1 + ... + σn]( μ1(BGP1) union ... union μn(BGPn) )</span><br><span class="line"></span><br><span class="line">since the domains of the σi RDF instance mappings are all mutually exclusive. Since they are also exclusive from SG,</span><br><span class="line"></span><br><span class="line">SG union [ σ1 + ... + σn]( μ1(BGP1) union ... union μn(BGPn) )</span><br><span class="line">= [ σ1 + ... + σn](SG union μ1(BGP1) union ... union μn(BGPn) )</span><br><span class="line"></span><br><span class="line">i.e.</span><br><span class="line"></span><br><span class="line">SG union μ1(BGP1) union ... union μn(BGPn)</span><br><span class="line"></span><br><span class="line">has an instance which is a subgraph of SG, so is simply entailed by SG by the RDF interpolation lemma [RDF-MT].</span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-tags"><a href="/tags/%E8%AF%AD%E4%B9%89Web/" rel="tag"># 语义Web</a></div><div class="post-nav"><div class="post-nav-item"><a href="/2021/03/21/SPARQL%201.1%20%E7%AC%94%E8%AE%B0(%E4%B8%89)/" rel="prev" title="SPARQL 1.1 笔记(三)"><i class="fa fa-chevron-left"></i> SPARQL 1.1 笔记(三)</a></div><div class="post-nav-item"><a href="/2021/03/21/SPARQL%201.1%20%E7%AC%94%E8%AE%B0(%E4%BA%94)/" rel="next" title="SPARQL 1.1 笔记(五)">SPARQL 1.1 笔记(五) <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><script>window.addEventListener("tabs:register",()=>{let{activeClass:t}=CONFIG.comments;if(CONFIG.comments.storage&&(t=localStorage.getItem("comments_active")||t),t){let e=document.querySelector(`a[href="#comment-${t}"]`);e&&e.click()}}),CONFIG.comments.storage&&window.addEventListener("tabs:click",t=>{if(!t.target.matches(".tabs-comment .tab-content .tab-pane"))return;let e=t.target.classList[1];localStorage.setItem("comments_active",e)})</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#18-SPARQL-%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">1.</span> <span class="nav-text">18 SPARQL 的定义</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#18-1-%E5%88%9D%E5%A7%8B%E5%AE%9A%E4%B9%89"><span class="nav-number">1.1.</span> <span class="nav-text">18.1 初始定义</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#18-1-1-RDF-Terms"><span class="nav-number">1.1.1.</span> <span class="nav-text">18.1.1 RDF Terms</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#18-1-2-%E7%AE%80%E5%8D%95%E6%96%87%E5%AD%97"><span class="nav-number">1.1.2.</span> <span class="nav-text">18.1.2 简单文字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#18-1-3-RDF%E6%95%B0%E6%8D%AE%E9%9B%86"><span class="nav-number">1.1.3.</span> <span class="nav-text">18.1.3 RDF数据集</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#18-1-4-%E6%9F%A5%E8%AF%A2%E5%8F%98%E9%87%8F"><span class="nav-number">1.1.4.</span> <span class="nav-text">18.1.4 查询变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#18-1-5-%E4%B8%89%E5%85%83%E7%BB%84%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.1.5.</span> <span class="nav-text">18.1.5 三元组模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#18-1-6-%E5%9F%BA%E6%9C%AC%E5%9B%BE%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.1.6.</span> <span class="nav-text">18.1.6 基本图模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#18-1-7-%E5%B1%9E%E6%80%A7%E8%B7%AF%E5%BE%84%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.1.7.</span> <span class="nav-text">18.1.7 属性路径模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#18-1-8-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E6%98%A0%E5%B0%84"><span class="nav-number">1.1.8.</span> <span class="nav-text">18.1.8 解决方案映射</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#18-1-9-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E5%BA%8F%E5%88%97%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="nav-number">1.1.9.</span> <span class="nav-text">18.1.9 解决方案序列修饰符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#18-1-10-SPARQL-%E6%9F%A5%E8%AF%A2"><span class="nav-number">1.1.10.</span> <span class="nav-text">18.1.10 SPARQL 查询</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18-2-%E8%BD%AC%E5%8C%96%E4%B8%BASPARQL%E4%BB%A3%E6%95%B0"><span class="nav-number">1.2.</span> <span class="nav-text">18.2 转化为SPARQL代数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#18-2-1-%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-number">1.2.1.</span> <span class="nav-text">18.2.1 变量作用域</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#18-2-2-%E8%BD%AC%E6%8D%A2%E5%9B%BE%E5%BD%A2%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.2.2.</span> <span class="nav-text">18.2.2 转换图形模式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#18-2-2-1-%E6%89%A9%E5%B1%95%E8%AF%AD%E6%B3%95%E5%BD%A2%E5%BC%8F"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">18.2.2.1 扩展语法形式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#18-2-2-2-%E6%94%B6%E9%9B%86FILTER%E5%85%83%E7%B4%A0"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">18.2.2.2 收集FILTER元素</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#18-2-2-3-%E8%BD%AC%E6%8D%A2%E5%B1%9E%E6%80%A7%E8%B7%AF%E5%BE%84%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">1.2.2.3.</span> <span class="nav-text">18.2.2.3 转换属性路径表达式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#18-2-2-4-%E8%BD%AC%E6%8D%A2%E5%B1%9E%E6%80%A7%E8%B7%AF%E5%BE%84%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.2.2.4.</span> <span class="nav-text">18.2.2.4 转换属性路径模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#18-2-2-5-%E8%BD%AC%E6%8D%A2%E5%9F%BA%E6%9C%AC%E5%9B%BE%E5%BD%A2%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.2.2.5.</span> <span class="nav-text">18.2.2.5 转换基本图形模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#18-2-2-6-%E8%BD%AC%E6%8D%A2%E5%9B%BE%E5%BD%A2%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.2.2.6.</span> <span class="nav-text">18.2.2.6 转换图形模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#18-2-2-7-%E7%BB%84%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="nav-number">1.2.2.7.</span> <span class="nav-text">18.2.2.7 组过滤器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#18-2-2-8-%E7%AE%80%E5%8C%96%E6%AD%A5%E9%AA%A4"><span class="nav-number">1.2.2.8.</span> <span class="nav-text">18.2.2.8 简化步骤</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#18-2-3-%E6%98%A0%E5%B0%84%E5%9B%BE%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%A4%BA%E4%BE%8B"><span class="nav-number">1.2.3.</span> <span class="nav-text">18.2.3 映射图模式的示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#18-2-4-%E8%BD%AC%E6%8D%A2%E7%BB%84%EF%BC%8C%E9%9B%86%E5%90%88%EF%BC%8CHAVING%EF%BC%8C%E6%9C%80%E7%BB%88VALUES%E5%AD%90%E5%8F%A5%E5%92%8CSELECT%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">1.2.4.</span> <span class="nav-text">18.2.4 转换组，集合，HAVING，最终VALUES子句和SELECT表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#18-2-4-1-%E5%88%86%E7%BB%84%E5%92%8C%E8%81%9A%E5%90%88"><span class="nav-number">1.2.4.1.</span> <span class="nav-text">18.2.4.1 分组和聚合</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#18-2-4-2-HAVING"><span class="nav-number">1.2.4.2.</span> <span class="nav-text">18.2.4.2 HAVING</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#18-2-4-3-VALUES"><span class="nav-number">1.2.4.3.</span> <span class="nav-text">18.2.4.3 VALUES</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#18-2-4-4-SELECT%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">1.2.4.4.</span> <span class="nav-text">18.2.4.4 SELECT表达式</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#18-2-5-%E8%BD%AC%E6%8D%A2%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="nav-number">1.2.5.</span> <span class="nav-text">18.2.5 转换解决方案修饰符</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#18-2-5-1-ORDER-BY"><span class="nav-number">1.2.5.1.</span> <span class="nav-text">18.2.5.1 ORDER BY</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#18-2-5-2-Projection"><span class="nav-number">1.2.5.2.</span> <span class="nav-text">18.2.5.2 Projection</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#18-2-5-3-DISTINCT"><span class="nav-number">1.2.5.3.</span> <span class="nav-text">18.2.5.3 DISTINCT</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#18-2-5-4-REDUCED"><span class="nav-number">1.2.5.4.</span> <span class="nav-text">18.2.5.4 REDUCED</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#18-2-5-5-OFFSET-and-LIMIT"><span class="nav-number">1.2.5.5.</span> <span class="nav-text">18.2.5.5 OFFSET and LIMIT</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#18-2-5-6-Final-Algebra-Expression"><span class="nav-number">1.2.5.6.</span> <span class="nav-text">18.2.5.6 Final Algebra Expression</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18-3%E5%9F%BA%E6%9C%AC%E5%9B%BE%E5%BD%A2%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.3.</span> <span class="nav-text">18.3基本图形模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#18-3-1-SPARQL-%E5%9F%BA%E6%9C%AC%E5%9B%BE%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="nav-number">1.3.1.</span> <span class="nav-text">18.3.1 SPARQL 基本图模式匹配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#18-3-2-%E7%A9%BA%E7%99%BD%E8%8A%82%E7%82%B9%E7%9A%84%E5%A4%84%E7%90%86"><span class="nav-number">1.3.2.</span> <span class="nav-text">18.3.2 空白节点的处理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18-4-%E5%B1%9E%E6%80%A7%E8%B7%AF%E5%BE%84%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.4.</span> <span class="nav-text">18.4 属性路径模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18-5-SPARQL%E4%BB%A3%E6%95%B0%E5%BC%8F"><span class="nav-number">1.5.</span> <span class="nav-text">18.5 SPARQL代数式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#18-5-1-%E8%81%9A%E5%90%88%E4%BB%A3%E6%95%B0%E5%BC%8F"><span class="nav-number">1.5.1.</span> <span class="nav-text">18.5.1 聚合代数式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#18-5-1-1-Set-Functions"><span class="nav-number">1.5.1.1.</span> <span class="nav-text">18.5.1.1 Set Functions</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#18-5-1-2-Count"><span class="nav-number">1.5.1.2.</span> <span class="nav-text">18.5.1.2 Count</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#18-5-1-3-Sum"><span class="nav-number">1.5.1.3.</span> <span class="nav-text">18.5.1.3 Sum</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#18-5-1-4-Avg"><span class="nav-number">1.5.1.4.</span> <span class="nav-text">18.5.1.4 Avg</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#18-5-1-5-Min"><span class="nav-number">1.5.1.5.</span> <span class="nav-text">18.5.1.5 Min</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#18-5-1-6-Max"><span class="nav-number">1.5.1.6.</span> <span class="nav-text">18.5.1.6 Max</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#18-5-1-7-GroupConcat"><span class="nav-number">1.5.1.7.</span> <span class="nav-text">18.5.1.7 GroupConcat</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#18-5-1-8-Sample"><span class="nav-number">1.5.1.8.</span> <span class="nav-text">18.5.1.8 Sample</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18-6-%E8%AF%84%E4%BC%B0%E8%AF%AD%E4%B9%89"><span class="nav-number">1.6.</span> <span class="nav-text">18.6 评估语义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18-7-%E6%89%A9%E5%B1%95SPARQL%E5%9F%BA%E6%9C%AC%E5%9B%BE%E5%8C%B9%E9%85%8D"><span class="nav-number">1.7.</span> <span class="nav-text">18.7 扩展SPARQL基本图匹配</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#18-7-1-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">1.7.1.</span> <span class="nav-text">18.7.1 注意事项</span></a></li></ol></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Cheryl Qi" src="/images/profile.jpg"><p class="site-author-name" itemprop="name">Cheryl Qi</p><div class="site-description" itemprop="description">Cheryl's Blog</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">26</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">7</span> <span class="site-state-item-name">标签</span></a></div></nav></div></div><script type="text/javascript" charset="utf-8" src="/js/tagcloud.js"></script><script type="text/javascript" charset="utf-8" src="/js/tagcanvas.js"></script><div class="widget-wrap"><h3 class="widget-title"></h3><div id="myCanvasContainer" class="widget tagcloud"><canvas width="250" height="250" id="resCanvas" style="width:100%"><ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%97%B6%E5%BA%8F%E6%95%B0%E6%8D%AE/" rel="tag">时序数据</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%97%B6%E7%A9%BA%E5%85%B3%E7%B3%BB/" rel="tag">时空关系</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%97%B6%E7%A9%BA%E6%8E%A8%E7%90%86/" rel="tag">时空推理</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE/" rel="tag">空间数据</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AF%AD%E4%B9%89Web/" rel="tag">语义Web</a><span class="tag-list-count">8</span></li></ul></canvas></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2021</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Cheryl Qi</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-chart-area"></i> </span><span title="站点总字数">168k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span title="站点阅读时长">5:05</span></div><div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动</div><div class="busuanzi-count"><script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span></span></span></div></div></footer></div><script size="300" alpha="0.6" zindex="-1" src="/lib/canvas-ribbon/canvas-ribbon.js"></script><script src="/lib/anime.min.js"></script><script src="/lib/pjax/pjax.min.js"></script><script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script><script src="//cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script>var pjax=new Pjax({selectors:["head title","#page-configurations",".content-wrap",".post-toc-wrap",".languages","#pjax"],switches:{".post-toc-wrap":Pjax.switches.innerHTML},analytics:!1,cacheBust:!1,scrollTo:!CONFIG.bookmark.enable});window.addEventListener("pjax:success",()=>{document.querySelectorAll("script[data-pjax], script#page-configurations, #pjax script").forEach(e=>{var t=e.text||e.textContent||e.innerHTML||"",a=e.parentNode;a.removeChild(e);var s=document.createElement("script");e.id&&(s.id=e.id),e.className&&(s.className=e.className),e.type&&(s.type=e.type),e.src&&(s.src=e.src,s.async=!1),void 0!==e.dataset.pjax&&(s.dataset.pjax=""),""!==t&&s.appendChild(document.createTextNode(t)),a.appendChild(s)}),NexT.boot.refresh(),CONFIG.motion.enable&&NexT.motion.integrator.init().add(NexT.motion.middleWares.subMenu).add(NexT.motion.middleWares.postList).bootstrap(),NexT.utils.updateSidebarPosition()})</script><script defer src="/lib/three/three.min.js"></script><script defer src="/lib/three/canvas_sphere.min.js"></script><div id="pjax"></div></body></html>